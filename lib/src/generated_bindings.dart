// ignore_for_file: always_specify_types, camel_case_types, non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// Auto-generated bindings for libjpeg-turbo
class LibJpegTurboBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibJpegTurboBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibJpegTurboBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// iMCU width (in pixels) for a given level of chrominance subsampling
  ///
  /// In a typical lossy JPEG image, 8x8 blocks of DCT coefficients for each
  /// component are interleaved in a single scan.  If the image uses chrominance
  /// subsampling, then multiple luminance blocks are stored together, followed by
  /// a single block for each chrominance component.  The minimum set of
  /// full-resolution luminance block(s) and corresponding (possibly subsampled)
  /// chrominance blocks necessary to represent at least one DCT block per
  /// component is called a "Minimum Coded Unit" or "MCU".  (For example, an MCU
  /// in an interleaved lossy JPEG image that uses 4:2:2 subsampling consists of
  /// two luminance blocks followed by one block for each chrominance component.)
  /// In a non-interleaved lossy JPEG image, each component is stored in a
  /// separate scan, and an MCU is a single DCT block, so we use the term "iMCU"
  /// (interleaved MCU) to refer to the equivalent of an MCU in an interleaved
  /// JPEG image.  For the common case of interleaved JPEG images, an iMCU is the
  /// same as an MCU.
  ///
  /// iMCU sizes:
  /// - 8x8 for no subsampling or grayscale
  /// - 16x8 for 4:2:2
  /// - 8x16 for 4:4:0
  /// - 16x16 for 4:2:0
  /// - 32x8 for 4:1:1
  /// - 8x32 for 4:4:1
  late final ffi.Pointer<ffi.Int> _tjMCUWidth = _lookup<ffi.Int>('tjMCUWidth');

  ffi.Pointer<ffi.Int> get tjMCUWidth => _tjMCUWidth;

  /// iMCU height (in pixels) for a given level of chrominance subsampling
  ///
  /// In a typical lossy JPEG image, 8x8 blocks of DCT coefficients for each
  /// component are interleaved in a single scan.  If the image uses chrominance
  /// subsampling, then multiple luminance blocks are stored together, followed by
  /// a single block for each chrominance component.  The minimum set of
  /// full-resolution luminance block(s) and corresponding (possibly subsampled)
  /// chrominance blocks necessary to represent at least one DCT block per
  /// component is called a "Minimum Coded Unit" or "MCU".  (For example, an MCU
  /// in an interleaved lossy JPEG image that uses 4:2:2 subsampling consists of
  /// two luminance blocks followed by one block for each chrominance component.)
  /// In a non-interleaved lossy JPEG image, each component is stored in a
  /// separate scan, and an MCU is a single DCT block, so we use the term "iMCU"
  /// (interleaved MCU) to refer to the equivalent of an MCU in an interleaved
  /// JPEG image.  For the common case of interleaved JPEG images, an iMCU is the
  /// same as an MCU.
  ///
  /// iMCU sizes:
  /// - 8x8 for no subsampling or grayscale
  /// - 16x8 for 4:2:2
  /// - 8x16 for 4:4:0
  /// - 16x16 for 4:2:0
  /// - 32x8 for 4:1:1
  /// - 8x32 for 4:4:1
  late final ffi.Pointer<ffi.Int> _tjMCUHeight = _lookup<ffi.Int>(
    'tjMCUHeight',
  );

  ffi.Pointer<ffi.Int> get tjMCUHeight => _tjMCUHeight;

  /// Red offset (in samples) for a given pixel format
  ///
  /// This specifies the number of samples that the red component is offset from
  /// the start of the pixel.  For instance, if an 8-bit-per-component pixel of
  /// format TJPF_BGRX is stored in `unsigned char pixel[]`, then the red
  /// component is `pixel[tjRedOffset[TJPF_BGRX]]`.  The offset is -1 if the pixel
  /// format does not have a red component.
  late final ffi.Pointer<ffi.Int> _tjRedOffset = _lookup<ffi.Int>(
    'tjRedOffset',
  );

  ffi.Pointer<ffi.Int> get tjRedOffset => _tjRedOffset;

  /// Green offset (in samples) for a given pixel format
  ///
  /// This specifies the number of samples that the green component is offset from
  /// the start of the pixel.  For instance, if an 8-bit-per-component pixel of
  /// format TJPF_BGRX is stored in `unsigned char pixel[]`, then the green
  /// component is `pixel[tjGreenOffset[TJPF_BGRX]]`.  The offset is -1 if the
  /// pixel format does not have a green component.
  late final ffi.Pointer<ffi.Int> _tjGreenOffset = _lookup<ffi.Int>(
    'tjGreenOffset',
  );

  ffi.Pointer<ffi.Int> get tjGreenOffset => _tjGreenOffset;

  /// Blue offset (in samples) for a given pixel format
  ///
  /// This specifies the number of samples that the blue component is offset from
  /// the start of the pixel.  For instance, if an 8-bit-per-component pixel of
  /// format TJPF_BGRX is stored in `unsigned char pixel[]`, then the blue
  /// component is `pixel[tjBlueOffset[TJPF_BGRX]]`.  The offset is -1 if the
  /// pixel format does not have a blue component.
  late final ffi.Pointer<ffi.Int> _tjBlueOffset = _lookup<ffi.Int>(
    'tjBlueOffset',
  );

  ffi.Pointer<ffi.Int> get tjBlueOffset => _tjBlueOffset;

  /// Alpha offset (in samples) for a given pixel format
  ///
  /// This specifies the number of samples that the alpha component is offset from
  /// the start of the pixel.  For instance, if an 8-bit-per-component pixel of
  /// format TJPF_BGRA is stored in `unsigned char pixel[]`, then the alpha
  /// component is `pixel[tjAlphaOffset[TJPF_BGRA]]`.  The offset is -1 if the
  /// pixel format does not have an alpha component.
  late final ffi.Pointer<ffi.Int> _tjAlphaOffset = _lookup<ffi.Int>(
    'tjAlphaOffset',
  );

  ffi.Pointer<ffi.Int> get tjAlphaOffset => _tjAlphaOffset;

  /// Pixel size (in samples) for a given pixel format
  late final ffi.Pointer<ffi.Int> _tjPixelSize = _lookup<ffi.Int>(
    'tjPixelSize',
  );

  ffi.Pointer<ffi.Int> get tjPixelSize => _tjPixelSize;

  /// A #tjregion structure that specifies no cropping
  late final ffi.Pointer<tjregion> _TJUNCROPPED = _lookup<tjregion>(
    'TJUNCROPPED',
  );

  tjregion get TJUNCROPPED => _TJUNCROPPED.ref;

  /// A #tjscalingfactor structure that specifies a scaling factor of 1/1 (no
  /// scaling)
  late final ffi.Pointer<tjscalingfactor> _TJUNSCALED =
      _lookup<tjscalingfactor>('TJUNSCALED');

  tjscalingfactor get TJUNSCALED => _TJUNSCALED.ref;

  /// Create a new TurboJPEG instance.
  ///
  /// @param initType one of the @ref TJINIT "initialization options"
  ///
  /// @return a handle to the newly-created instance, or NULL if an error occurred
  /// (see #tj3GetErrorStr().)
  tjhandle tj3Init(int initType) {
    return _tj3Init(initType);
  }

  late final _tj3InitPtr =
      _lookup<ffi.NativeFunction<tjhandle Function(ffi.Int)>>('tj3Init');
  late final _tj3Init = _tj3InitPtr.asFunction<tjhandle Function(int)>();

  /// Destroy a TurboJPEG instance.
  ///
  /// @param handle handle to a TurboJPEG instance.  If the handle is NULL, then
  /// this function has no effect.
  void tj3Destroy(tjhandle handle) {
    return _tj3Destroy(handle);
  }

  late final _tj3DestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(tjhandle)>>('tj3Destroy');
  late final _tj3Destroy = _tj3DestroyPtr.asFunction<void Function(tjhandle)>();

  /// Returns a descriptive error message explaining why the last command failed.
  ///
  /// @param handle handle to a TurboJPEG instance, or NULL if the error was
  /// generated by a global function (but note that retrieving the error message
  /// for a global function is thread-safe only on platforms that support
  /// thread-local storage.)
  ///
  /// @return a descriptive error message explaining why the last command failed.
  ffi.Pointer<ffi.Char> tj3GetErrorStr(tjhandle handle) {
    return _tj3GetErrorStr(handle);
  }

  late final _tj3GetErrorStrPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(tjhandle)>>(
        'tj3GetErrorStr',
      );
  late final _tj3GetErrorStr = _tj3GetErrorStrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(tjhandle)>();

  /// Returns a code indicating the severity of the last error.  See
  /// @ref TJERR "Error codes".
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @return a code indicating the severity of the last error.  See
  /// @ref TJERR "Error codes".
  int tj3GetErrorCode(tjhandle handle) {
    return _tj3GetErrorCode(handle);
  }

  late final _tj3GetErrorCodePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle)>>(
        'tj3GetErrorCode',
      );
  late final _tj3GetErrorCode = _tj3GetErrorCodePtr
      .asFunction<int Function(tjhandle)>();

  /// Set the value of a parameter.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param param one of the @ref TJPARAM "parameters"
  ///
  /// @param value value of the parameter (refer to @ref TJPARAM
  /// "parameter documentation")
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3Set(tjhandle handle, int param, int value) {
    return _tj3Set(handle, param, value);
  }

  late final _tj3SetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle, ffi.Int, ffi.Int)>>(
        'tj3Set',
      );
  late final _tj3Set = _tj3SetPtr
      .asFunction<int Function(tjhandle, int, int)>();

  /// Get the value of a parameter.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param param one of the @ref TJPARAM "parameters"
  ///
  /// @return the value of the specified parameter, or -1 if the value is unknown.
  int tj3Get(tjhandle handle, int param) {
    return _tj3Get(handle, param);
  }

  late final _tj3GetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle, ffi.Int)>>(
        'tj3Get',
      );
  late final _tj3Get = _tj3GetPtr.asFunction<int Function(tjhandle, int)>();

  /// Allocate a byte buffer for use with TurboJPEG.  You should always use this
  /// function to allocate the JPEG destination buffer(s) for the compression and
  /// transform functions unless you are disabling automatic buffer (re)allocation
  /// (by setting #TJPARAM_NOREALLOC.)
  ///
  /// @param bytes the number of bytes to allocate
  ///
  /// @return a pointer to a newly-allocated buffer with the specified number of
  /// bytes.
  ///
  /// @see tj3Free()
  ffi.Pointer<ffi.Void> tj3Alloc(int bytes) {
    return _tj3Alloc(bytes);
  }

  late final _tj3AllocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
        'tj3Alloc',
      );
  late final _tj3Alloc = _tj3AllocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Free a byte buffer previously allocated by TurboJPEG.  You should always use
  /// this function to free JPEG destination buffer(s) that were automatically
  /// (re)allocated by the compression and transform functions or that were
  /// manually allocated using #tj3Alloc().
  ///
  /// @param buffer address of the buffer to free.  If the address is NULL, then
  /// this function has no effect.
  ///
  /// @see tj3Alloc()
  void tj3Free(ffi.Pointer<ffi.Void> buffer) {
    return _tj3Free(buffer);
  }

  late final _tj3FreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'tj3Free',
      );
  late final _tj3Free = _tj3FreePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// The maximum size of the buffer (in bytes) required to hold a JPEG image with
  /// the given parameters.  The number of bytes returned by this function is
  /// larger than the size of the uncompressed source image.  The reason for this
  /// is that the JPEG format uses 16-bit coefficients, so it is possible for a
  /// very high-quality source image with very high-frequency content to expand
  /// rather than compress when converted to the JPEG format.  Such images
  /// represent very rare corner cases, but since there is no way to predict the
  /// size of a JPEG image prior to compression, the corner cases have to be
  /// handled.
  ///
  /// @param width width (in pixels) of the image
  ///
  /// @param height height (in pixels) of the image
  ///
  /// @param jpegSubsamp the level of chrominance subsampling to be used when
  /// generating the JPEG image (see @ref TJSAMP
  /// "Chrominance subsampling options".)  #TJSAMP_UNKNOWN is treated like
  /// #TJSAMP_444, since a buffer large enough to hold a JPEG image with no
  /// subsampling should also be large enough to hold a JPEG image with an
  /// arbitrary level of subsampling.  Note that lossless JPEG images always
  /// use #TJSAMP_444.
  ///
  /// @return the maximum size of the buffer (in bytes) required to hold the
  /// image, or 0 if the arguments are out of bounds.
  int tj3JPEGBufSize(int width, int height, int jpegSubsamp) {
    return _tj3JPEGBufSize(width, height, jpegSubsamp);
  }

  late final _tj3JPEGBufSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Int, ffi.Int, ffi.Int)>>(
        'tj3JPEGBufSize',
      );
  late final _tj3JPEGBufSize = _tj3JPEGBufSizePtr
      .asFunction<int Function(int, int, int)>();

  /// The size of the buffer (in bytes) required to hold a unified planar YUV
  /// image with the given parameters.
  ///
  /// @param width width (in pixels) of the image
  ///
  /// @param align row alignment (in bytes) of the image (must be a power of 2.)
  /// Setting this parameter to n specifies that each row in each plane of the
  /// image will be padded to the nearest multiple of n bytes (1 = unpadded.)
  ///
  /// @param height height (in pixels) of the image
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the size of the buffer (in bytes) required to hold the image, or 0
  /// if the arguments are out of bounds.
  int tj3YUVBufSize(int width, int align, int height, int subsamp) {
    return _tj3YUVBufSize(width, align, height, subsamp);
  }

  late final _tj3YUVBufSizePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Size Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int)
        >
      >('tj3YUVBufSize');
  late final _tj3YUVBufSize = _tj3YUVBufSizePtr
      .asFunction<int Function(int, int, int, int)>();

  /// The size of the buffer (in bytes) required to hold a YUV image plane with
  /// the given parameters.
  ///
  /// @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)
  ///
  /// @param width width (in pixels) of the YUV image.  NOTE: This is the width of
  /// the whole image, not the plane width.
  ///
  /// @param stride bytes per row in the image plane.  Setting this to 0 is the
  /// equivalent of setting it to the plane width.
  ///
  /// @param height height (in pixels) of the YUV image.  NOTE: This is the height
  /// of the whole image, not the plane height.
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the size of the buffer (in bytes) required to hold the YUV image
  /// plane, or 0 if the arguments are out of bounds.
  int tj3YUVPlaneSize(
    int componentID,
    int width,
    int stride,
    int height,
    int subsamp,
  ) {
    return _tj3YUVPlaneSize(componentID, width, stride, height, subsamp);
  }

  late final _tj3YUVPlaneSizePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Size Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int)
        >
      >('tj3YUVPlaneSize');
  late final _tj3YUVPlaneSize = _tj3YUVPlaneSizePtr
      .asFunction<int Function(int, int, int, int, int)>();

  /// The plane width of a YUV image plane with the given parameters.  Refer to
  /// @ref YUVnotes "YUV Image Format Notes" for a description of plane width.
  ///
  /// @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)
  ///
  /// @param width width (in pixels) of the YUV image
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the plane width of a YUV image plane with the given parameters, or 0
  /// if the arguments are out of bounds.
  int tj3YUVPlaneWidth(int componentID, int width, int subsamp) {
    return _tj3YUVPlaneWidth(componentID, width, subsamp);
  }

  late final _tj3YUVPlaneWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
        'tj3YUVPlaneWidth',
      );
  late final _tj3YUVPlaneWidth = _tj3YUVPlaneWidthPtr
      .asFunction<int Function(int, int, int)>();

  /// The plane height of a YUV image plane with the given parameters.  Refer to
  /// @ref YUVnotes "YUV Image Format Notes" for a description of plane height.
  ///
  /// @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)
  ///
  /// @param height height (in pixels) of the YUV image
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the plane height of a YUV image plane with the given parameters, or
  /// 0 if the arguments are out of bounds.
  int tj3YUVPlaneHeight(int componentID, int height, int subsamp) {
    return _tj3YUVPlaneHeight(componentID, height, subsamp);
  }

  late final _tj3YUVPlaneHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
        'tj3YUVPlaneHeight',
      );
  late final _tj3YUVPlaneHeight = _tj3YUVPlaneHeightPtr
      .asFunction<int Function(int, int, int)>();

  /// Embed an ICC (International Color Consortium) color management profile in
  /// JPEG images generated by subsequent compression and lossless transformation
  /// operations.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param iccBuf pointer to a byte buffer containing an ICC profile.  A copy is
  /// made of the ICC profile, so this buffer can be freed or reused as soon as
  /// this function returns.  Setting this parameter to NULL or setting `iccSize`
  /// to 0 removes any ICC profile that was previously associated with the
  /// TurboJPEG instance.
  ///
  /// @param iccSize size of the ICC profile (in bytes.)  Setting this parameter
  /// to 0 or setting `iccBuf` to NULL removes any ICC profile that was previously
  /// associated with the TurboJPEG instance.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3SetICCProfile(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> iccBuf,
    int iccSize,
  ) {
    return _tj3SetICCProfile(handle, iccBuf, iccSize);
  }

  late final _tj3SetICCProfilePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, ffi.Size)
        >
      >('tj3SetICCProfile');
  late final _tj3SetICCProfile = _tj3SetICCProfilePtr
      .asFunction<int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Compress a packed-pixel RGB, grayscale, or CMYK image with 2 to 8 bits of
  /// data precision per sample into a JPEG image with the same data precision.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,
  /// or CMYK source image to be compressed.  This buffer should normally be
  /// `pitch * height` samples in size.  However, you can also use this parameter
  /// to compress from a specific region of a larger buffer.  The data precision
  /// of the source image (from 2 to 8 bits per sample) can be specified using
  /// #TJPARAM_PRECISION and defaults to 8 if #TJPARAM_PRECISION is unset or out
  /// of range.
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch samples per row in the source image.  Normally this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.
  /// (Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this
  /// parameter to specify the row alignment/padding of the source image, to skip
  /// rows, or to compress from a specific region of a larger buffer.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param jpegBuf address of a pointer to a byte buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
  /// or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3JPEGBufSize() and adding the return value to the size of the ICC profile
  /// (if any) that was previously associated with the TurboJPEG instance (see
  /// #tj3SetICCProfile().)  This should ensure that the buffer never has to be
  /// re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)
  /// .
  /// Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`
  /// upon return from this function, as it may have changed.
  ///
  /// @param jpegSize pointer to a size_t variable that holds the size of the JPEG
  /// buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`
  /// should be set to the size of the buffer.  Otherwise, `*jpegSize` is
  /// ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a
  /// previous call to one of the JPEG compression functions, then `*jpegSize` is
  /// also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG
  /// image (in bytes.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3Compress8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3Compress8(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3Compress8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('tj3Compress8');
  late final _tj3Compress8 = _tj3Compress8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  /// Compress a packed-pixel RGB, grayscale, or CMYK image with 9 to 12 bits of
  /// data precision per sample into a JPEG image with the same data precision.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,
  /// or CMYK source image to be compressed.  This buffer should normally be
  /// `pitch * height` samples in size.  However, you can also use this parameter
  /// to compress from a specific region of a larger buffer.  The data precision
  /// of the source image (from 9 to 12 bits per sample) can be specified using
  /// #TJPARAM_PRECISION and defaults to 12 if #TJPARAM_PRECISION is unset or out
  /// of range.
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch samples per row in the source image.  Normally this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.
  /// (Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this
  /// parameter to specify the row alignment/padding of the source image, to skip
  /// rows, or to compress from a specific region of a larger buffer.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param jpegBuf address of a pointer to a byte buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
  /// or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3JPEGBufSize() and adding the return value to the size of the ICC profile
  /// (if any) that was previously associated with the TurboJPEG instance (see
  /// #tj3SetICCProfile().)  This should ensure that the buffer never has to be
  /// re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)
  /// .
  /// Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`
  /// upon return from this function, as it may have changed.
  ///
  /// @param jpegSize pointer to a size_t variable that holds the size of the JPEG
  /// buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`
  /// should be set to the size of the buffer.  Otherwise, `*jpegSize` is
  /// ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a
  /// previous call to one of the JPEG compression functions, then `*jpegSize` is
  /// also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG
  /// image (in bytes.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3Compress12(
    tjhandle handle,
    ffi.Pointer<ffi.Short> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3Compress12(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3Compress12Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.Short>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('tj3Compress12');
  late final _tj3Compress12 = _tj3Compress12Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.Short>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  /// Compress a packed-pixel RGB, grayscale, or CMYK image with 13 to 16 bits of
  /// data precision per sample into a lossless JPEG image with the same data
  /// precision.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,
  /// or CMYK source image to be compressed.  This buffer should normally be
  /// `pitch * height` samples in size.  However, you can also use this parameter
  /// to compress from a specific region of a larger buffer.  The data precision
  /// of the source image (from 13 to 16 bits per sample) can be specified using
  /// #TJPARAM_PRECISION and defaults to 16 if #TJPARAM_PRECISION is unset or out
  /// of range.
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch samples per row in the source image.  Normally this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.
  /// (Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this
  /// parameter to specify the row alignment/padding of the source image, to skip
  /// rows, or to compress from a specific region of a larger buffer.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param jpegBuf address of a pointer to a byte buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
  /// or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3JPEGBufSize() and adding the return value to the size of the ICC profile
  /// (if any) that was previously associated with the TurboJPEG instance (see
  /// #tj3SetICCProfile().)  This should ensure that the buffer never has to be
  /// re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)
  /// .
  /// Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`
  /// upon return from this function, as it may have changed.
  ///
  /// @param jpegSize pointer to a size_t variable that holds the size of the JPEG
  /// buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`
  /// should be set to the size of the buffer.  Otherwise, `*jpegSize` is
  /// ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a
  /// previous call to one of the JPEG compression functions, then `*jpegSize` is
  /// also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG
  /// image (in bytes.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3Compress16(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedShort> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3Compress16(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3Compress16Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedShort>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('tj3Compress16');
  late final _tj3Compress16 = _tj3Compress16Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedShort>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  /// Compress a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into
  /// an 8-bit-per-sample lossy @ref TJCS_YCbCr "YCbCr" or
  /// @ref TJCS_GRAY "grayscale" JPEG image.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if compressing a grayscale image) that contain a YUV
  /// source image to be compressed.  These planes can be contiguous or
  /// non-contiguous in memory.  The size of each plane should match the value
  /// returned by #tj3YUVPlaneSize() for the given image width, height, strides,
  /// and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer to
  /// @ref YUVnotes "YUV Image Format Notes" for more details.
  ///
  /// @param width width (in pixels) of the source image.  If the width is not an
  /// even multiple of the iMCU width (see #tjMCUWidth), then an intermediate
  /// buffer copy will be performed.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// row in the corresponding plane of the YUV source image.  Setting the stride
  /// for any plane to 0 is the same as setting it to the plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If `strides` is NULL, then the
  /// strides for all planes will be set to their respective plane widths.  You
  /// can adjust the strides in order to specify an arbitrary amount of row
  /// padding in each plane or to create a JPEG image from a subregion of a larger
  /// planar YUV image.
  ///
  /// @param height height (in pixels) of the source image.  If the height is not
  /// an even multiple of the iMCU height (see #tjMCUHeight), then an intermediate
  /// buffer copy will be performed.
  ///
  /// @param jpegBuf address of a pointer to a byte buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
  /// or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3JPEGBufSize() and adding the return value to the size of the ICC profile
  /// (if any) that was previously associated with the TurboJPEG instance (see
  /// #tj3SetICCProfile().)  This should ensure that the buffer never has to be
  /// re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)
  /// .
  /// Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`
  /// upon return from this function, as it may have changed.
  ///
  /// @param jpegSize pointer to a size_t variable that holds the size of the JPEG
  /// buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`
  /// should be set to the size of the buffer.  Otherwise, `*jpegSize` is
  /// ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a
  /// previous call to one of the JPEG compression functions, then `*jpegSize` is
  /// also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG
  /// image (in bytes.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3CompressFromYUVPlanes8(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> srcPlanes,
    int width,
    ffi.Pointer<ffi.Int> strides,
    int height,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3CompressFromYUVPlanes8(
      handle,
      srcPlanes,
      width,
      strides,
      height,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3CompressFromYUVPlanes8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Int,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('tj3CompressFromYUVPlanes8');
  late final _tj3CompressFromYUVPlanes8 = _tj3CompressFromYUVPlanes8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          int,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  /// Compress an 8-bit-per-sample unified planar YUV image into an
  /// 8-bit-per-sample lossy @ref TJCS_YCbCr "YCbCr" or @ref TJCS_GRAY "grayscale"
  /// JPEG image.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a unified planar YUV source
  /// image to be compressed.  The size of this buffer should match the value
  /// returned by #tj3YUVBufSize() for the given image width, height, row
  /// alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The
  /// Y, U (Cb), and V (Cr) image planes should be stored sequentially in the
  /// buffer.  (Refer to @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param width width (in pixels) of the source image.  If the width is not an
  /// even multiple of the iMCU width (see #tjMCUWidth), then an intermediate
  /// buffer copy will be performed.
  ///
  /// @param align row alignment (in bytes) of the source image (must be a power
  /// of 2.)  Setting this parameter to n indicates that each row in each plane of
  /// the source image is padded to the nearest multiple of n bytes
  /// (1 = unpadded.)
  ///
  /// @param height height (in pixels) of the source image.  If the height is not
  /// an even multiple of the iMCU height (see #tjMCUHeight), then an intermediate
  /// buffer copy will be performed.
  ///
  /// @param jpegBuf address of a pointer to a byte buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
  /// or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3JPEGBufSize() and adding the return value to the size of the ICC profile
  /// (if any) that was previously associated with the TurboJPEG instance (see
  /// #tj3SetICCProfile().)  This should ensure that the buffer never has to be
  /// re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)
  /// .
  /// Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`
  /// upon return from this function, as it may have changed.
  ///
  /// @param jpegSize pointer to a size_t variable that holds the size of the JPEG
  /// buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`
  /// should be set to the size of the buffer.  Otherwise, `*jpegSize` is
  /// ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a
  /// previous call to one of the JPEG compression functions, then `*jpegSize` is
  /// also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG
  /// image (in bytes.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3CompressFromYUV8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int align,
    int height,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3CompressFromYUV8(
      handle,
      srcBuf,
      width,
      align,
      height,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3CompressFromYUV8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('tj3CompressFromYUV8');
  late final _tj3CompressFromYUV8 = _tj3CompressFromYUV8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  /// Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into separate
  /// 8-bit-per-sample Y, U (Cb), and V (Cr) image planes.  This function performs
  /// color conversion and downsampling (which are accelerated in the
  /// libjpeg-turbo implementation) but does not execute any of the other steps in
  /// the JPEG compression process.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale
  /// source image to be encoded.  This buffer should normally be `pitch * height`
  /// bytes in size.  However, you can also use this parameter to encode from a
  /// specific region of a larger buffer.
  ///
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch bytes per row in the source image.  Normally this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.
  /// (Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this
  /// parameter to specify the row alignment/padding of the source image, to skip
  /// rows, or to encode from a specific region of a larger packed-pixel image.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if generating a grayscale image) that will receive the
  /// encoded image.  These planes can be contiguous or non-contiguous in memory.
  /// Use #tj3YUVPlaneSize() to determine the appropriate size for each plane
  /// based on the image width, height, strides, and level of chrominance
  /// subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes
  /// "YUV Image Format Notes" for more details.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// row in the corresponding plane of the YUV image.  Setting the stride for any
  /// plane to 0 is the same as setting it to the plane width (see @ref YUVnotes
  /// "YUV Image Format Notes".)  If `strides` is NULL, then the strides for all
  /// planes will be set to their respective plane widths.  You can adjust the
  /// strides in order to add an arbitrary amount of row padding to each plane or
  /// to encode an RGB or grayscale image into a subregion of a larger planar YUV
  /// image.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3EncodeYUVPlanes8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstPlanes,
    ffi.Pointer<ffi.Int> strides,
  ) {
    return _tj3EncodeYUVPlanes8(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstPlanes,
      strides,
    );
  }

  late final _tj3EncodeYUVPlanes8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('tj3EncodeYUVPlanes8');
  late final _tj3EncodeYUVPlanes8 = _tj3EncodeYUVPlanes8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  /// Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into an
  /// 8-bit-per-sample unified planar YUV image.  This function performs color
  /// conversion and downsampling (which are accelerated in the libjpeg-turbo
  /// implementation) but does not execute any of the other steps in the JPEG
  /// compression process.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale
  /// source image to be encoded.  This buffer should normally be `pitch * height`
  /// bytes in size.  However, you can also use this parameter to encode from a
  /// specific region of a larger buffer.
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch bytes per row in the source image.  Normally this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.
  /// (Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this
  /// parameter to specify the row alignment/padding of the source image, to skip
  /// rows, or to encode from a specific region of a larger packed-pixel image.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param dstBuf pointer to a buffer that will receive the unified planar YUV
  /// image.  Use #tj3YUVBufSize() to determine the appropriate size for this
  /// buffer based on the image width, height, row alignment, and level of
  /// chrominance subsampling (see #TJPARAM_SUBSAMP.)  The Y, U (Cb), and V (Cr)
  /// image planes will be stored sequentially in the buffer.  (Refer to
  /// @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param align row alignment (in bytes) of the YUV image (must be a power of
  /// 2.)  Setting this parameter to n will cause each row in each plane of the
  /// YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)
  /// To generate images suitable for X Video, `align` should be set to 4.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3EncodeYUV8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int align,
  ) {
    return _tj3EncodeYUV8(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstBuf,
      align,
    );
  }

  late final _tj3EncodeYUV8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
          )
        >
      >('tj3EncodeYUV8');
  late final _tj3EncodeYUV8 = _tj3EncodeYUV8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
        )
      >();

  /// Retrieve information about a JPEG image without decompressing it, or prime
  /// the decompressor with quantization and Huffman tables.  If a JPEG image is
  /// passed to this function, then the @ref TJPARAM "parameters" that describe
  /// the JPEG image will be set when the function returns.  If a JPEG image is
  /// passed to this function and #TJPARAM_SAVEMARKERS is set to `2` or `4`, then
  /// the ICC profile (if any) will be extracted from the JPEG image.
  /// (#tj3GetICCProfile() can then be used to retrieve the profile.)
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param jpegBuf pointer to a byte buffer containing a JPEG image or an
  /// "abbreviated table specification" (AKA "tables-only") datastream.  Passing a
  /// tables-only datastream to this function primes the decompressor with
  /// quantization and Huffman tables that can be used when decompressing
  /// subsequent "abbreviated image" datastreams.  This is useful, for instance,
  /// when decompressing video streams in which all frames share the same
  /// quantization and Huffman tables.
  ///
  /// @param jpegSize size of the JPEG image or tables-only datastream (in bytes)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecompressHeader(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
  ) {
    return _tj3DecompressHeader(handle, jpegBuf, jpegSize);
  }

  late final _tj3DecompressHeaderPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, ffi.Size)
        >
      >('tj3DecompressHeader');
  late final _tj3DecompressHeader = _tj3DecompressHeaderPtr
      .asFunction<int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Retrieve the ICC (International Color Consortium) color management profile
  /// (if any) that was previously extracted from a JPEG image.
  ///
  /// @note To extract the ICC profile from a JPEG image, call
  /// #tj3DecompressHeader() with #TJPARAM_SAVEMARKERS set to `2` or `4`.  Once
  /// the ICC profile is retrieved, it must be re-extracted before it can be
  /// retrieved again.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param iccBuf address of a pointer to a byte buffer.  Upon return:
  /// - If `iccBuf` is not NULL and there is an ICC profile to retrieve, then
  /// `*iccBuf` will point to a byte buffer containing the ICC profile.  This
  /// buffer should be freed using #tj3Free().
  /// - If `iccBuf` is not NULL and there is no ICC profile to retrieve, then
  /// `*iccBuf` will be NULL.
  /// - If `iccBuf` is NULL, then only the ICC profile size will be retrieved, and
  /// the ICC profile can be retrieved later.
  ///
  /// @param iccSize address of a size_t variable.  Upon return, the variable will
  /// contain the ICC profile size (or 0 if there is no ICC profile to retrieve.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3GetICCProfile(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> iccBuf,
    ffi.Pointer<ffi.Size> iccSize,
  ) {
    return _tj3GetICCProfile(handle, iccBuf, iccSize);
  }

  late final _tj3GetICCProfilePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Size>,
          )
        >
      >('tj3GetICCProfile');
  late final _tj3GetICCProfile = _tj3GetICCProfilePtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Size>,
        )
      >();

  /// Returns a list of fractional scaling factors that the JPEG decompressor
  /// supports.
  ///
  /// @param numScalingFactors pointer to an integer variable that will receive
  /// the number of elements in the list
  ///
  /// @return a pointer to a list of fractional scaling factors, or NULL if an
  /// error is encountered (see #tj3GetErrorStr().)
  ffi.Pointer<tjscalingfactor> tj3GetScalingFactors(
    ffi.Pointer<ffi.Int> numScalingFactors,
  ) {
    return _tj3GetScalingFactors(numScalingFactors);
  }

  late final _tj3GetScalingFactorsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<tjscalingfactor> Function(ffi.Pointer<ffi.Int>)
        >
      >('tj3GetScalingFactors');
  late final _tj3GetScalingFactors = _tj3GetScalingFactorsPtr
      .asFunction<
        ffi.Pointer<tjscalingfactor> Function(ffi.Pointer<ffi.Int>)
      >();

  /// Set the scaling factor for subsequent lossy decompression operations.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param scalingFactor #tjscalingfactor structure that specifies a fractional
  /// scaling factor that the decompressor supports (see #tj3GetScalingFactors()),
  /// or <tt>#TJUNSCALED</tt> for no scaling.  Decompression scaling is a function
  /// of the IDCT algorithm, so scaling factors are generally limited to multiples
  /// of 1/8.  If the entire JPEG image will be decompressed, then the width and
  /// height of the scaled destination image can be determined by calling
  /// #TJSCALED() with the JPEG width and height (see #TJPARAM_JPEGWIDTH and
  /// #TJPARAM_JPEGHEIGHT) and the specified scaling factor.  When decompressing
  /// into a planar YUV image, an intermediate buffer copy will be performed if
  /// the width or height of the scaled destination image is not an even multiple
  /// of the iMCU size (see #tjMCUWidth and #tjMCUHeight.)  Note that
  /// decompression scaling is not available (and the specified scaling factor is
  /// ignored) when decompressing lossless JPEG images (see #TJPARAM_LOSSLESS),
  /// since the IDCT algorithm is not used with those images.  Note also that
  /// #TJPARAM_FASTDCT is ignored when decompression scaling is enabled.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3SetScalingFactor(tjhandle handle, tjscalingfactor scalingFactor) {
    return _tj3SetScalingFactor(handle, scalingFactor);
  }

  late final _tj3SetScalingFactorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle, tjscalingfactor)>>(
        'tj3SetScalingFactor',
      );
  late final _tj3SetScalingFactor = _tj3SetScalingFactorPtr
      .asFunction<int Function(tjhandle, tjscalingfactor)>();

  /// Set the cropping region for partially decompressing a lossy JPEG image into
  /// a packed-pixel image
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param croppingRegion #tjregion structure that specifies a subregion of the
  /// JPEG image to decompress, or <tt>#TJUNCROPPED</tt> for no cropping.  The
  /// left boundary of the cropping region must be evenly divisible by the scaled
  /// iMCU width-- <tt>#TJSCALED(#tjMCUWidth[subsamp], scalingFactor)</tt>, where
  /// `subsamp` is the level of chrominance subsampling in the JPEG image (see
  /// #TJPARAM_SUBSAMP) and `scalingFactor` is the decompression scaling factor
  /// (see #tj3SetScalingFactor().)  The cropping region should be specified
  /// relative to the scaled image dimensions.  Unless `croppingRegion` is
  /// <tt>#TJUNCROPPED</tt>, the JPEG header must be read (see
  /// #tj3DecompressHeader()) prior to calling this function.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3SetCroppingRegion(tjhandle handle, tjregion croppingRegion) {
    return _tj3SetCroppingRegion(handle, croppingRegion);
  }

  late final _tj3SetCroppingRegionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle, tjregion)>>(
        'tj3SetCroppingRegion',
      );
  late final _tj3SetCroppingRegion = _tj3SetCroppingRegionPtr
      .asFunction<int Function(tjhandle, tjregion)>();

  /// Decompress a JPEG image with 2 to 8 bits of data precision per sample into a
  /// packed-pixel RGB, grayscale, or CMYK image with the same data precision.
  /// The @ref TJPARAM "parameters" that describe the JPEG image will be set when
  /// this function returns.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param jpegBuf pointer to a byte buffer containing the JPEG image to
  /// decompress
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param dstBuf pointer to a buffer that will receive the packed-pixel
  /// decompressed image.  This buffer should normally be
  /// `pitch * destinationHeight` samples in size.  However, you can also use this
  /// parameter to decompress into a specific region of a larger buffer.  NOTE:
  /// If the JPEG image is lossy, then `destinationHeight` is either the scaled
  /// JPEG height (see #TJSCALED(), #TJPARAM_JPEGHEIGHT, and
  /// #tj3SetScalingFactor()) or the height of the cropping region (see
  /// #tj3SetCroppingRegion().)  If the JPEG image is lossless, then
  /// `destinationHeight` is the JPEG height.
  ///
  /// @param pitch samples per row in the destination image.  Normally this should
  /// be set to <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>, if the
  /// destination image should be unpadded.  (Setting this parameter to 0 is the
  /// equivalent of setting it to
  /// <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>.)  However, you can
  /// also use this parameter to specify the row alignment/padding of the
  /// destination image, to skip rows, or to decompress into a specific region of
  /// a larger buffer.  NOTE: If the JPEG image is lossy, then `destinationWidth`
  /// is either the scaled JPEG width (see #TJSCALED(), #TJPARAM_JPEGWIDTH, and
  /// #tj3SetScalingFactor()) or the width of the cropping region (see
  /// #tj3SetCroppingRegion().)  If the JPEG image is lossless, then
  /// `destinationWidth` is the JPEG width.
  ///
  /// @param pixelFormat pixel format of the destination image (see @ref
  /// TJPF "Pixel formats".)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3Decompress8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int pitch,
    int pixelFormat,
  ) {
    return _tj3Decompress8(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      pitch,
      pixelFormat,
    );
  }

  late final _tj3Decompress8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Size,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tj3Decompress8');
  late final _tj3Decompress8 = _tj3Decompress8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
        )
      >();

  /// Decompress a JPEG image with 9 to 12 bits of data precision per sample into
  /// a packed-pixel RGB, grayscale, or CMYK image with the same data precision.
  ///
  /// \details \copydetails tj3Decompress8()
  int tj3Decompress12(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Short> dstBuf,
    int pitch,
    int pixelFormat,
  ) {
    return _tj3Decompress12(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      pitch,
      pixelFormat,
    );
  }

  late final _tj3Decompress12Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Size,
            ffi.Pointer<ffi.Short>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tj3Decompress12');
  late final _tj3Decompress12 = _tj3Decompress12Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.Short>,
          int,
          int,
        )
      >();

  /// Decompress a lossless JPEG image with 13 to 16 bits of data precision per
  /// sample into a packed-pixel RGB, grayscale, or CMYK image with the same
  /// data precision.
  ///
  /// \details \copydetails tj3Decompress8()
  int tj3Decompress16(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedShort> dstBuf,
    int pitch,
    int pixelFormat,
  ) {
    return _tj3Decompress16(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      pitch,
      pixelFormat,
    );
  }

  late final _tj3Decompress16Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Size,
            ffi.Pointer<ffi.UnsignedShort>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tj3Decompress16');
  late final _tj3Decompress16 = _tj3Decompress16Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedShort>,
          int,
          int,
        )
      >();

  /// Decompress an 8-bit-per-sample lossy JPEG image into separate
  /// 8-bit-per-sample Y, U (Cb), and V (Cr) image planes.  This function performs
  /// JPEG decompression but leaves out the color conversion step, so a planar YUV
  /// image is generated instead of a packed-pixel image.  The
  /// @ref TJPARAM "parameters" that describe the JPEG image will be set when this
  /// function returns.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param jpegBuf pointer to a byte buffer containing the JPEG image to
  /// decompress
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if decompressing a grayscale image) that will receive
  /// the decompressed image.  These planes can be contiguous or non-contiguous in
  /// memory.  Use #tj3YUVPlaneSize() to determine the appropriate size for each
  /// plane based on the scaled JPEG width and height (see #TJSCALED(),
  /// #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()),
  /// strides, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer
  /// to @ref YUVnotes "YUV Image Format Notes" for more details.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// row in the corresponding plane of the YUV image.  Setting the stride for any
  /// plane to 0 is the same as setting it to the scaled plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If `strides` is NULL, then the
  /// strides for all planes will be set to their respective scaled plane widths.
  /// You can adjust the strides in order to add an arbitrary amount of row
  /// padding to each plane or to decompress the JPEG image into a subregion of a
  /// larger planar YUV image.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecompressToYUVPlanes8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstPlanes,
    ffi.Pointer<ffi.Int> strides,
  ) {
    return _tj3DecompressToYUVPlanes8(
      handle,
      jpegBuf,
      jpegSize,
      dstPlanes,
      strides,
    );
  }

  late final _tj3DecompressToYUVPlanes8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Size,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('tj3DecompressToYUVPlanes8');
  late final _tj3DecompressToYUVPlanes8 = _tj3DecompressToYUVPlanes8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  /// Decompress an 8-bit-per-sample lossy JPEG image into an 8-bit-per-sample
  /// unified planar YUV image.  This function performs JPEG decompression but
  /// leaves out the color conversion step, so a planar YUV image is generated
  /// instead of a packed-pixel image.  The @ref TJPARAM "parameters" that
  /// describe the JPEG image will be set when this function returns.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param jpegBuf pointer to a byte buffer containing the JPEG image to
  /// decompress
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param dstBuf pointer to a buffer that will receive the unified planar YUV
  /// decompressed image.  Use #tj3YUVBufSize() to determine the appropriate size
  /// for this buffer based on the scaled JPEG width and height (see #TJSCALED(),
  /// #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()), row
  /// alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The
  /// Y, U (Cb), and V (Cr) image planes will be stored sequentially in the
  /// buffer.  (Refer to @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param align row alignment (in bytes) of the YUV image (must be a power of
  /// 2.)  Setting this parameter to n will cause each row in each plane of the
  /// YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)
  /// To generate images suitable for X Video, `align` should be set to 4.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecompressToYUV8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int align,
  ) {
    return _tj3DecompressToYUV8(handle, jpegBuf, jpegSize, dstBuf, align);
  }

  late final _tj3DecompressToYUV8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Size,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
          )
        >
      >('tj3DecompressToYUV8');
  late final _tj3DecompressToYUV8 = _tj3DecompressToYUV8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
        )
      >();

  /// Decode a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into an
  /// 8-bit-per-sample packed-pixel RGB or grayscale image.  This function
  /// performs color conversion (which is accelerated in the libjpeg-turbo
  /// implementation) but does not execute any of the other steps in the JPEG
  /// decompression process.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if decoding a grayscale image) that contain a YUV image
  /// to be decoded.  These planes can be contiguous or non-contiguous in memory.
  /// The size of each plane should match the value returned by #tj3YUVPlaneSize()
  /// for the given image width, height, strides, and level of chrominance
  /// subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes
  /// "YUV Image Format Notes" for more details.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// row in the corresponding plane of the YUV source image.  Setting the stride
  /// for any plane to 0 is the same as setting it to the plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If `strides` is NULL, then the
  /// strides for all planes will be set to their respective plane widths.  You
  /// can adjust the strides in order to specify an arbitrary amount of row
  /// padding in each plane or to decode a subregion of a larger planar YUV image.
  ///
  /// @param dstBuf pointer to a buffer that will receive the packed-pixel decoded
  /// image.  This buffer should normally be `pitch * height` bytes in size.
  /// However, you can also use this parameter to decode into a specific region of
  /// a larger buffer.
  ///
  /// @param width width (in pixels) of the source and destination images
  ///
  /// @param pitch bytes per row in the destination image.  Normally this should
  /// be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination
  /// image should be unpadded.  (Setting this parameter to 0 is the equivalent of
  /// setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can
  /// also use this parameter to specify the row alignment/padding of the
  /// destination image, to skip rows, or to decode into a specific region of a
  /// larger buffer.
  ///
  /// @param height height (in pixels) of the source and destination images
  ///
  /// @param pixelFormat pixel format of the destination image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecodeYUVPlanes8(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> srcPlanes,
    ffi.Pointer<ffi.Int> strides,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3DecodeYUVPlanes8(
      handle,
      srcPlanes,
      strides,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3DecodeYUVPlanes8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tj3DecodeYUVPlanes8');
  late final _tj3DecodeYUVPlanes8 = _tj3DecodeYUVPlanes8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
        )
      >();

  /// Decode an 8-bit-per-sample unified planar YUV image into an 8-bit-per-sample
  /// packed-pixel RGB or grayscale image.  This function performs color
  /// conversion (which is accelerated in the libjpeg-turbo implementation) but
  /// does not execute any of the other steps in the JPEG decompression process.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param srcBuf pointer to a buffer containing a unified planar YUV source
  /// image to be decoded.  The size of this buffer should match the value
  /// returned by #tj3YUVBufSize() for the given image width, height, row
  /// alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The
  /// Y, U (Cb), and V (Cr) image planes should be stored sequentially in the
  /// source buffer.  (Refer to @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param align row alignment (in bytes) of the YUV source image (must be a
  /// power of 2.)  Setting this parameter to n indicates that each row in each
  /// plane of the YUV source image is padded to the nearest multiple of n bytes
  /// (1 = unpadded.)
  ///
  /// @param dstBuf pointer to a buffer that will receive the packed-pixel decoded
  /// image.  This buffer should normally be `pitch * height` bytes in size.
  /// However, you can also use this parameter to decode into a specific region of
  /// a larger buffer.
  ///
  /// @param width width (in pixels) of the source and destination images
  ///
  /// @param pitch bytes per row in the destination image.  Normally this should
  /// be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination
  /// image should be unpadded.  (Setting this parameter to 0 is the equivalent of
  /// setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can
  /// also use this parameter to specify the row alignment/padding of the
  /// destination image, to skip rows, or to decode into a specific region of a
  /// larger buffer.
  ///
  /// @param height height (in pixels) of the source and destination images
  ///
  /// @param pixelFormat pixel format of the destination image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecodeYUV8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int align,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3DecodeYUV8(
      handle,
      srcBuf,
      align,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3DecodeYUV8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tj3DecodeYUV8');
  late final _tj3DecodeYUV8 = _tj3DecodeYUV8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
        )
      >();

  /// The maximum size of the buffer (in bytes) required to hold a JPEG image
  /// transformed with the given transform parameters and/or cropping region.
  /// This function is a wrapper for #tj3JPEGBufSize() that takes into account
  /// cropping, transposition of the width and height (which affects the
  /// destination image dimensions and level of chrominance subsampling),
  /// grayscale conversion, and the ICC profile (if any) that was previously
  /// associated with the TurboJPEG instance (see #tj3SetICCProfile()) or
  /// extracted from the source image (see #tj3GetICCProfile() and
  /// #TJPARAM_SAVEMARKERS.)  The JPEG header must be read (see
  /// tj3DecompressHeader()) prior to calling this function.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// lossless transformation
  ///
  /// @param transform pointer to a #tjtransform structure that specifies the
  /// transform parameters and/or cropping region for the JPEG image.
  ///
  /// @return the maximum size of the buffer (in bytes) required to hold the
  /// transformed image, or 0 if an error occurred (see #tj3GetErrorStr() and
  /// #tj3GetErrorCode().)
  int tj3TransformBufSize(tjhandle handle, ffi.Pointer<tjtransform> transform) {
    return _tj3TransformBufSize(handle, transform);
  }

  late final _tj3TransformBufSizePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Size Function(tjhandle, ffi.Pointer<tjtransform>)
        >
      >('tj3TransformBufSize');
  late final _tj3TransformBufSize = _tj3TransformBufSizePtr
      .asFunction<int Function(tjhandle, ffi.Pointer<tjtransform>)>();

  /// Losslessly transform a JPEG image into another JPEG image.  Lossless
  /// transforms work by moving the raw DCT coefficients from one JPEG image
  /// structure to another without altering the values of the coefficients.  While
  /// this is typically faster than decompressing the image, transforming it, and
  /// re-compressing it, lossless transforms are not free.  Each lossless
  /// transform requires reading and performing entropy decoding on all of the
  /// coefficients in the source image, regardless of the size of the destination
  /// image.  Thus, this function provides a means of generating multiple
  /// transformed images from the same source or applying multiple transformations
  /// simultaneously, in order to eliminate the need to read the source
  /// coefficients multiple times.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// lossless transformation
  ///
  /// @param jpegBuf pointer to a byte buffer containing the JPEG source image to
  /// transform
  ///
  /// @param jpegSize size of the JPEG source image (in bytes)
  ///
  /// @param n the number of transformed JPEG images to generate
  ///
  /// @param dstBufs pointer to an array of n byte buffers.  `dstBufs[i]` will
  /// receive a JPEG image that has been transformed using the parameters in
  /// `transforms[i]`.  TurboJPEG has the ability to reallocate the JPEG
  /// destination buffer to accommodate the size of the transformed JPEG image.
  /// Thus, you can choose to:
  /// -# pre-allocate the JPEG destination buffer with an arbitrary size using
  /// #tj3Alloc() and let TurboJPEG grow the buffer as needed,
  /// -# set `dstBufs[i]` to NULL to tell TurboJPEG to allocate the buffer for
  /// you, or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3TransformBufSize().  Under normal circumstances, this should ensure that
  /// the buffer never has to be re-allocated.  (Setting #TJPARAM_NOREALLOC
  /// guarantees that it won't be.  However, if the source image has a large
  /// amount of embedded Exif data, then the transformed JPEG image may be larger
  /// than the worst-case size.  #TJPARAM_NOREALLOC cannot be used in that case
  /// unless the embedded data is discarded using #TJXOPT_COPYNONE or
  /// #TJPARAM_SAVEMARKERS.)
  /// .
  /// Unless you have set #TJPARAM_NOREALLOC, you should always check `dstBufs[i]`
  /// upon return from this function, as it may have changed.
  ///
  /// @param dstSizes pointer to an array of n size_t variables that will receive
  /// the actual sizes (in bytes) of each transformed JPEG image.  If `dstBufs[i]`
  /// points to a pre-allocated buffer, then `dstSizes[i]` should be set to the
  /// size of the buffer.  Otherwise, `dstSizes[i]` is ignored.  Upon return,
  /// `dstSizes[i]` will contain the size of the transformed JPEG image (in
  /// bytes.)
  ///
  /// @param transforms pointer to an array of n #tjtransform structures, each of
  /// which specifies the transform parameters and/or cropping region for the
  /// corresponding transformed JPEG image.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3Transform(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    int n,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstBufs,
    ffi.Pointer<ffi.Size> dstSizes,
    ffi.Pointer<tjtransform> transforms,
  ) {
    return _tj3Transform(
      handle,
      jpegBuf,
      jpegSize,
      n,
      dstBufs,
      dstSizes,
      transforms,
    );
  }

  late final _tj3TransformPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Size,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Size>,
            ffi.Pointer<tjtransform>,
          )
        >
      >('tj3Transform');
  late final _tj3Transform = _tj3TransformPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<tjtransform>,
        )
      >();

  /// Load a packed-pixel image with 2 to 8 bits of data precision per sample from
  /// disk into memory.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param filename name of a file containing a packed-pixel image in Windows
  /// BMP or PBMPLUS (PPM/PGM) format.  Windows BMP files require 8-bit-per-sample
  /// data precision.  When loading a PBMPLUS file, the target data precision
  /// (from 2 to 8 bits per sample) can be specified using #TJPARAM_PRECISION and
  /// defaults to 8 if #TJPARAM_PRECISION is unset or out of range.  If the data
  /// precision of the PBMPLUS file does not match the target data precision, then
  /// upconverting or downconverting will be performed.
  ///
  /// @param width pointer to an integer variable that will receive the width (in
  /// pixels) of the packed-pixel image
  ///
  /// @param align row alignment (in samples) of the packed-pixel buffer to be
  /// returned (must be a power of 2.)  Setting this parameter to n will cause all
  /// rows in the buffer to be padded to the nearest multiple of n samples
  /// (1 = unpadded.)
  ///
  /// @param height pointer to an integer variable that will receive the height
  /// (in pixels) of the packed-pixel image
  ///
  /// @param pixelFormat pointer to an integer variable that specifies or will
  /// receive the pixel format of the packed-pixel buffer.  The behavior of this
  /// function varies depending on the value of `*pixelFormat` passed to the
  /// function:
  /// - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will
  /// use the most optimal pixel format for the file type, and `*pixelFormat` will
  /// contain the ID of that pixel format upon successful return from this
  /// function.
  /// - @ref TJPF_GRAY : Only PGM files and 8-bit-per-pixel BMP files with a
  /// grayscale colormap can be loaded.
  /// - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be
  /// converted using a quick & dirty algorithm that is suitable only for testing
  /// purposes.  (Proper conversion between CMYK and other formats requires a
  /// color management system.)
  /// - Other @ref TJPF "pixel formats" : The packed-pixel buffer will use the
  /// specified pixel format, and pixel format conversion will be performed if
  /// necessary.
  ///
  /// @return a pointer to a newly-allocated buffer containing the packed-pixel
  /// image, converted to the chosen pixel format and with the chosen row
  /// alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This
  /// buffer should be freed using #tj3Free().
  ffi.Pointer<ffi.UnsignedChar> tj3LoadImage8(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Int> width,
    int align,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> pixelFormat,
  ) {
    return _tj3LoadImage8(handle, filename, width, align, height, pixelFormat);
  }

  late final _tj3LoadImage8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
            tjhandle,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('tj3LoadImage8');
  late final _tj3LoadImage8 = _tj3LoadImage8Ptr
      .asFunction<
        ffi.Pointer<ffi.UnsignedChar> Function(
          tjhandle,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  /// Load a packed-pixel image with 9 to 12 bits of data precision per sample
  /// from disk into memory.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param filename name of a file containing a packed-pixel image in PBMPLUS
  /// (PPM/PGM) format.  The target data precision (from 9 to 12 bits per sample)
  /// can be specified using #TJPARAM_PRECISION and defaults to 12 if
  /// #TJPARAM_PRECISION is unset or out of range.  If the data precision of the
  /// PBMPLUS file does not match the target data precision, then upconverting or
  /// downconverting will be performed.
  ///
  /// @param width pointer to an integer variable that will receive the width (in
  /// pixels) of the packed-pixel image
  ///
  /// @param align row alignment (in samples) of the packed-pixel buffer to be
  /// returned (must be a power of 2.)  Setting this parameter to n will cause all
  /// rows in the buffer to be padded to the nearest multiple of n samples
  /// (1 = unpadded.)
  ///
  /// @param height pointer to an integer variable that will receive the height
  /// (in pixels) of the packed-pixel image
  ///
  /// @param pixelFormat pointer to an integer variable that specifies or will
  /// receive the pixel format of the packed-pixel buffer.  The behavior of this
  /// function will vary depending on the value of `*pixelFormat` passed to the
  /// function:
  /// - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will
  /// use the most optimal pixel format for the file type, and `*pixelFormat` will
  /// contain the ID of that pixel format upon successful return from this
  /// function.
  /// - @ref TJPF_GRAY : Only PGM files can be loaded.
  /// - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be
  /// converted using a quick & dirty algorithm that is suitable only for testing
  /// purposes.  (Proper conversion between CMYK and other formats requires a
  /// color management system.)
  /// - Other @ref TJPF "pixel formats" : The packed-pixel buffer will use the
  /// specified pixel format, and pixel format conversion will be performed if
  /// necessary.
  ///
  /// @return a pointer to a newly-allocated buffer containing the packed-pixel
  /// image, converted to the chosen pixel format and with the chosen row
  /// alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This
  /// buffer should be freed using #tj3Free().
  ffi.Pointer<ffi.Short> tj3LoadImage12(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Int> width,
    int align,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> pixelFormat,
  ) {
    return _tj3LoadImage12(handle, filename, width, align, height, pixelFormat);
  }

  late final _tj3LoadImage12Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Short> Function(
            tjhandle,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('tj3LoadImage12');
  late final _tj3LoadImage12 = _tj3LoadImage12Ptr
      .asFunction<
        ffi.Pointer<ffi.Short> Function(
          tjhandle,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  /// Load a packed-pixel image with 13 to 16 bits of data precision per sample
  /// from disk into memory.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param filename name of a file containing a packed-pixel image in PBMPLUS
  /// (PPM/PGM) format.  The target data precision (from 13 to 16 bits per sample)
  /// can be specified using #TJPARAM_PRECISION and defaults to 16 if
  /// #TJPARAM_PRECISION is unset or out of range.  If the data precision of the
  /// PBMPLUS file does not match the target data precision, then upconverting or
  /// downconverting will be performed.
  ///
  /// @param width pointer to an integer variable that will receive the width (in
  /// pixels) of the packed-pixel image
  ///
  /// @param align row alignment (in samples) of the packed-pixel buffer to be
  /// returned (must be a power of 2.)  Setting this parameter to n will cause all
  /// rows in the buffer to be padded to the nearest multiple of n samples
  /// (1 = unpadded.)
  ///
  /// @param height pointer to an integer variable that will receive the height
  /// (in pixels) of the packed-pixel image
  ///
  /// @param pixelFormat pointer to an integer variable that specifies or will
  /// receive the pixel format of the packed-pixel buffer.  The behavior of this
  /// function will vary depending on the value of `*pixelFormat` passed to the
  /// function:
  /// - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will
  /// use the most optimal pixel format for the file type, and `*pixelFormat` will
  /// contain the ID of that pixel format upon successful return from this
  /// function.
  /// - @ref TJPF_GRAY : Only PGM files can be loaded.
  /// - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be
  /// converted using a quick & dirty algorithm that is suitable only for testing
  /// purposes.  (Proper conversion between CMYK and other formats requires a
  /// color management system.)
  /// - Other @ref TJPF "pixel formats" : The packed-pixel buffer will use the
  /// specified pixel format, and pixel format conversion will be performed if
  /// necessary.
  ///
  /// @return a pointer to a newly-allocated buffer containing the packed-pixel
  /// image, converted to the chosen pixel format and with the chosen row
  /// alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This
  /// buffer should be freed using #tj3Free().
  ffi.Pointer<ffi.UnsignedShort> tj3LoadImage16(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Int> width,
    int align,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> pixelFormat,
  ) {
    return _tj3LoadImage16(handle, filename, width, align, height, pixelFormat);
  }

  late final _tj3LoadImage16Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
            tjhandle,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('tj3LoadImage16');
  late final _tj3LoadImage16 = _tj3LoadImage16Ptr
      .asFunction<
        ffi.Pointer<ffi.UnsignedShort> Function(
          tjhandle,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  /// Save a packed-pixel image with 2 to 8 bits of data precision per sample from
  /// memory to disk.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param filename name of a file to which to save the packed-pixel image.  The
  /// image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format, depending
  /// on the file extension.  Windows BMP files require 8-bit-per-sample data
  /// precision.  When saving a PBMPLUS file, the source data precision (from 2 to
  /// 8 bits per sample) can be specified using #TJPARAM_PRECISION and defaults to
  /// 8 if #TJPARAM_PRECISION is unset or out of range.
  ///
  /// @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,
  /// or CMYK image to be saved
  ///
  /// @param width width (in pixels) of the packed-pixel image
  ///
  /// @param pitch samples per row in the packed-pixel image.  Setting this
  /// parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the packed-pixel image
  ///
  /// @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF
  /// "Pixel formats".)  If this parameter is set to @ref TJPF_GRAY, then the
  /// image will be stored in PGM or 8-bit-per-pixel (indexed color) BMP format.
  /// Otherwise, the image will be stored in PPM or 24-bit-per-pixel BMP format.
  /// If this parameter is set to @ref TJPF_CMYK, then the CMYK pixels will be
  /// converted to RGB using a quick & dirty algorithm that is suitable only for
  /// testing purposes.  (Proper conversion between CMYK and other formats
  /// requires a color management system.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3SaveImage8(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.UnsignedChar> buffer,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3SaveImage8(
      handle,
      filename,
      buffer,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3SaveImage8Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tj3SaveImage8');
  late final _tj3SaveImage8 = _tj3SaveImage8Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
        )
      >();

  /// Save a packed-pixel image with 9 to 12 bits of data precision per sample
  /// from memory to disk.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param filename name of a file to which to save the packed-pixel image,
  /// which will be stored in PBMPLUS (PPM/PGM) format.  The source data precision
  /// (from 9 to 12 bits per sample) can be specified using #TJPARAM_PRECISION and
  /// defaults to 12 if #TJPARAM_PRECISION is unset or out of range.
  ///
  /// @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,
  /// or CMYK image to be saved
  ///
  /// @param width width (in pixels) of the packed-pixel image
  ///
  /// @param pitch samples per row in the packed-pixel image.  Setting this
  /// parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the packed-pixel image
  ///
  /// @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF
  /// "Pixel formats".)  If this parameter is set to @ref TJPF_GRAY, then the
  /// image will be stored in PGM format.  Otherwise, the image will be stored in
  /// PPM format.  If this parameter is set to @ref TJPF_CMYK, then the CMYK
  /// pixels will be converted to RGB using a quick & dirty algorithm that is
  /// suitable only for testing purposes.  (Proper conversion between CMYK and
  /// other formats requires a color management system.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3SaveImage12(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Short> buffer,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3SaveImage12(
      handle,
      filename,
      buffer,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3SaveImage12Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Short>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tj3SaveImage12');
  late final _tj3SaveImage12 = _tj3SaveImage12Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Short>,
          int,
          int,
          int,
          int,
        )
      >();

  /// Save a packed-pixel image with 13 to 16 bits of data precision per sample
  /// from memory to disk.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param filename name of a file to which to save the packed-pixel image,
  /// which will be stored in PBMPLUS (PPM/PGM) format.  The source data precision
  /// (from 13 to 16 bits per sample) can be specified using #TJPARAM_PRECISION
  /// and defaults to 16 if #TJPARAM_PRECISION is unset or out of range.
  ///
  /// @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,
  /// or CMYK image to be saved
  ///
  /// @param width width (in pixels) of the packed-pixel image
  ///
  /// @param pitch samples per row in the packed-pixel image.  Setting this
  /// parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the packed-pixel image
  ///
  /// @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF
  /// "Pixel formats".)  If this parameter is set to @ref TJPF_GRAY, then the
  /// image will be stored in PGM format.  Otherwise, the image will be stored in
  /// PPM format.  If this parameter is set to @ref TJPF_CMYK, then the CMYK
  /// pixels will be converted to RGB using a quick & dirty algorithm that is
  /// suitable only for testing purposes.  (Proper conversion between CMYK and
  /// other formats requires a color management system.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3SaveImage16(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.UnsignedShort> buffer,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3SaveImage16(
      handle,
      filename,
      buffer,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3SaveImage16Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.UnsignedShort>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tj3SaveImage16');
  late final _tj3SaveImage16 = _tj3SaveImage16Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedShort>,
          int,
          int,
          int,
          int,
        )
      >();

  int TJBUFSIZE(int width, int height) {
    return _TJBUFSIZE(width, height);
  }

  late final _TJBUFSIZEPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Int, ffi.Int)>>(
        'TJBUFSIZE',
      );
  late final _TJBUFSIZE = _TJBUFSIZEPtr.asFunction<int Function(int, int)>();

  int tjCompress(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    ffi.Pointer<ffi.UnsignedLong> compressedSize,
    int jpegSubsamp,
    int jpegQual,
    int flags,
  ) {
    return _tjCompress(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelSize,
      dstBuf,
      compressedSize,
      jpegSubsamp,
      jpegQual,
      flags,
    );
  }

  late final _tjCompressPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Pointer<ffi.UnsignedLong>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjCompress');
  late final _tjCompress = _tjCompressPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedLong>,
          int,
          int,
          int,
        )
      >();

  int tjDecompress(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelSize,
    int flags,
  ) {
    return _tjDecompress(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      width,
      pitch,
      height,
      pixelSize,
      flags,
    );
  }

  late final _tjDecompressPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjDecompress');
  late final _tjDecompress = _tjDecompressPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          int,
        )
      >();

  int tjDecompressHeader(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _tjDecompressHeader(handle, jpegBuf, jpegSize, width, height);
  }

  late final _tjDecompressHeaderPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('tjDecompressHeader');
  late final _tjDecompressHeader = _tjDecompressHeaderPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  int tjDestroy(tjhandle handle) {
    return _tjDestroy(handle);
  }

  late final _tjDestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle)>>('tjDestroy');
  late final _tjDestroy = _tjDestroyPtr.asFunction<int Function(tjhandle)>();

  ffi.Pointer<ffi.Char> tjGetErrorStr() {
    return _tjGetErrorStr();
  }

  late final _tjGetErrorStrPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'tjGetErrorStr',
      );
  late final _tjGetErrorStr = _tjGetErrorStrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  tjhandle tjInitCompress() {
    return _tjInitCompress();
  }

  late final _tjInitCompressPtr =
      _lookup<ffi.NativeFunction<tjhandle Function()>>('tjInitCompress');
  late final _tjInitCompress = _tjInitCompressPtr
      .asFunction<tjhandle Function()>();

  tjhandle tjInitDecompress() {
    return _tjInitDecompress();
  }

  late final _tjInitDecompressPtr =
      _lookup<ffi.NativeFunction<tjhandle Function()>>('tjInitDecompress');
  late final _tjInitDecompress = _tjInitDecompressPtr
      .asFunction<tjhandle Function()>();

  int TJBUFSIZEYUV(int width, int height, int jpegSubsamp) {
    return _TJBUFSIZEYUV(width, height, jpegSubsamp);
  }

  late final _TJBUFSIZEYUVPtr =
      _lookup<
        ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Int, ffi.Int, ffi.Int)>
      >('TJBUFSIZEYUV');
  late final _TJBUFSIZEYUV =
      _TJBUFSIZEYUVPtr.asFunction<int Function(int, int, int)>();

  int tjDecompressHeader2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> jpegSubsamp,
  ) {
    return _tjDecompressHeader2(
      handle,
      jpegBuf,
      jpegSize,
      width,
      height,
      jpegSubsamp,
    );
  }

  late final _tjDecompressHeader2Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('tjDecompressHeader2');
  late final _tjDecompressHeader2 = _tjDecompressHeader2Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  int tjDecompressToYUV(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int flags,
  ) {
    return _tjDecompressToYUV(handle, jpegBuf, jpegSize, dstBuf, flags);
  }

  late final _tjDecompressToYUVPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
          )
        >
      >('tjDecompressToYUV');
  late final _tjDecompressToYUV = _tjDecompressToYUVPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
        )
      >();

  int tjEncodeYUV(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUV(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelSize,
      dstBuf,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUVPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjEncodeYUV');
  late final _tjEncodeYUV = _tjEncodeYUVPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
        )
      >();

  ffi.Pointer<ffi.UnsignedChar> tjAlloc(int bytes) {
    return _tjAlloc(bytes);
  }

  late final _tjAllocPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<ffi.UnsignedChar> Function(ffi.Int)>
      >('tjAlloc');
  late final _tjAlloc = _tjAllocPtr
      .asFunction<ffi.Pointer<ffi.UnsignedChar> Function(int)>();

  int tjBufSize(int width, int height, int jpegSubsamp) {
    return _tjBufSize(width, height, jpegSubsamp);
  }

  late final _tjBufSizePtr =
      _lookup<
        ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Int, ffi.Int, ffi.Int)>
      >('tjBufSize');
  late final _tjBufSize = _tjBufSizePtr
      .asFunction<int Function(int, int, int)>();

  int tjBufSizeYUV(int width, int height, int subsamp) {
    return _tjBufSizeYUV(width, height, subsamp);
  }

  late final _tjBufSizeYUVPtr =
      _lookup<
        ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Int, ffi.Int, ffi.Int)>
      >('tjBufSizeYUV');
  late final _tjBufSizeYUV = _tjBufSizeYUVPtr
      .asFunction<int Function(int, int, int)>();

  int tjCompress2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.UnsignedLong> jpegSize,
    int jpegSubsamp,
    int jpegQual,
    int flags,
  ) {
    return _tjCompress2(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      jpegBuf,
      jpegSize,
      jpegSubsamp,
      jpegQual,
      flags,
    );
  }

  late final _tjCompress2Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.UnsignedLong>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjCompress2');
  late final _tjCompress2 = _tjCompress2Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedLong>,
          int,
          int,
          int,
        )
      >();

  int tjDecompress2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjDecompress2(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjDecompress2Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjDecompress2');
  late final _tjDecompress2 = _tjDecompress2Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          int,
        )
      >();

  int tjEncodeYUV2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUV2(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstBuf,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUV2Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjEncodeYUV2');
  late final _tjEncodeYUV2 = _tjEncodeYUV2Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
        )
      >();

  void tjFree(ffi.Pointer<ffi.UnsignedChar> buffer) {
    return _tjFree(buffer);
  }

  late final _tjFreePtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>)>
      >('tjFree');
  late final _tjFree = _tjFreePtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>)>();

  ffi.Pointer<tjscalingfactor> tjGetScalingFactors(
    ffi.Pointer<ffi.Int> numscalingfactors,
  ) {
    return _tjGetScalingFactors(numscalingfactors);
  }

  late final _tjGetScalingFactorsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<tjscalingfactor> Function(ffi.Pointer<ffi.Int>)
        >
      >('tjGetScalingFactors');
  late final _tjGetScalingFactors = _tjGetScalingFactorsPtr
      .asFunction<
        ffi.Pointer<tjscalingfactor> Function(ffi.Pointer<ffi.Int>)
      >();

  tjhandle tjInitTransform() {
    return _tjInitTransform();
  }

  late final _tjInitTransformPtr =
      _lookup<ffi.NativeFunction<tjhandle Function()>>('tjInitTransform');
  late final _tjInitTransform = _tjInitTransformPtr
      .asFunction<tjhandle Function()>();

  int tjTransform(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    int n,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstBufs,
    ffi.Pointer<ffi.UnsignedLong> dstSizes,
    ffi.Pointer<tjtransform> transforms,
    int flags,
  ) {
    return _tjTransform(
      handle,
      jpegBuf,
      jpegSize,
      n,
      dstBufs,
      dstSizes,
      transforms,
      flags,
    );
  }

  late final _tjTransformPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedLong,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.UnsignedLong>,
            ffi.Pointer<tjtransform>,
            ffi.Int,
          )
        >
      >('tjTransform');
  late final _tjTransform = _tjTransformPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.Pointer<tjtransform>,
          int,
        )
      >();

  /// TurboJPEG 1.4+
  int tjBufSizeYUV2(int width, int align, int height, int subsamp) {
    return _tjBufSizeYUV2(width, align, height, subsamp);
  }

  late final _tjBufSizeYUV2Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int)
        >
      >('tjBufSizeYUV2');
  late final _tjBufSizeYUV2 = _tjBufSizeYUV2Ptr
      .asFunction<int Function(int, int, int, int)>();

  int tjCompressFromYUV(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int align,
    int height,
    int subsamp,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.UnsignedLong> jpegSize,
    int jpegQual,
    int flags,
  ) {
    return _tjCompressFromYUV(
      handle,
      srcBuf,
      width,
      align,
      height,
      subsamp,
      jpegBuf,
      jpegSize,
      jpegQual,
      flags,
    );
  }

  late final _tjCompressFromYUVPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.UnsignedLong>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjCompressFromYUV');
  late final _tjCompressFromYUV = _tjCompressFromYUVPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedLong>,
          int,
          int,
        )
      >();

  int tjCompressFromYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> srcPlanes,
    int width,
    ffi.Pointer<ffi.Int> strides,
    int height,
    int subsamp,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.UnsignedLong> jpegSize,
    int jpegQual,
    int flags,
  ) {
    return _tjCompressFromYUVPlanes(
      handle,
      srcPlanes,
      width,
      strides,
      height,
      subsamp,
      jpegBuf,
      jpegSize,
      jpegQual,
      flags,
    );
  }

  late final _tjCompressFromYUVPlanesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Int,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.UnsignedLong>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjCompressFromYUVPlanes');
  late final _tjCompressFromYUVPlanes = _tjCompressFromYUVPlanesPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          int,
          ffi.Pointer<ffi.Int>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedLong>,
          int,
          int,
        )
      >();

  int tjDecodeYUV(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int align,
    int subsamp,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjDecodeYUV(
      handle,
      srcBuf,
      align,
      subsamp,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjDecodeYUVPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjDecodeYUV');
  late final _tjDecodeYUV = _tjDecodeYUVPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          int,
        )
      >();

  int tjDecodeYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> srcPlanes,
    ffi.Pointer<ffi.Int> strides,
    int subsamp,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjDecodeYUVPlanes(
      handle,
      srcPlanes,
      strides,
      subsamp,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjDecodeYUVPlanesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjDecodeYUVPlanes');
  late final _tjDecodeYUVPlanes = _tjDecodeYUVPlanesPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          int,
        )
      >();

  int tjDecompressHeader3(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> jpegSubsamp,
    ffi.Pointer<ffi.Int> jpegColorspace,
  ) {
    return _tjDecompressHeader3(
      handle,
      jpegBuf,
      jpegSize,
      width,
      height,
      jpegSubsamp,
      jpegColorspace,
    );
  }

  late final _tjDecompressHeader3Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('tjDecompressHeader3');
  late final _tjDecompressHeader3 = _tjDecompressHeader3Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  int tjDecompressToYUV2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int align,
    int height,
    int flags,
  ) {
    return _tjDecompressToYUV2(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      width,
      align,
      height,
      flags,
    );
  }

  late final _tjDecompressToYUV2Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjDecompressToYUV2');
  late final _tjDecompressToYUV2 = _tjDecompressToYUV2Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
        )
      >();

  int tjDecompressToYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstPlanes,
    int width,
    ffi.Pointer<ffi.Int> strides,
    int height,
    int flags,
  ) {
    return _tjDecompressToYUVPlanes(
      handle,
      jpegBuf,
      jpegSize,
      dstPlanes,
      width,
      strides,
      height,
      flags,
    );
  }

  late final _tjDecompressToYUVPlanesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Int,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjDecompressToYUVPlanes');
  late final _tjDecompressToYUVPlanes = _tjDecompressToYUVPlanesPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          int,
          ffi.Pointer<ffi.Int>,
          int,
          int,
        )
      >();

  int tjEncodeYUV3(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int align,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUV3(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstBuf,
      align,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUV3Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjEncodeYUV3');
  late final _tjEncodeYUV3 = _tjEncodeYUV3Ptr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
        )
      >();

  int tjEncodeYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstPlanes,
    ffi.Pointer<ffi.Int> strides,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUVPlanes(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstPlanes,
      strides,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUVPlanesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            tjhandle,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjEncodeYUVPlanes');
  late final _tjEncodeYUVPlanes = _tjEncodeYUVPlanesPtr
      .asFunction<
        int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Int>,
          int,
          int,
        )
      >();

  int tjPlaneHeight(int componentID, int height, int subsamp) {
    return _tjPlaneHeight(componentID, height, subsamp);
  }

  late final _tjPlaneHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
        'tjPlaneHeight',
      );
  late final _tjPlaneHeight = _tjPlaneHeightPtr
      .asFunction<int Function(int, int, int)>();

  int tjPlaneSizeYUV(
    int componentID,
    int width,
    int stride,
    int height,
    int subsamp,
  ) {
    return _tjPlaneSizeYUV(componentID, width, stride, height, subsamp);
  }

  late final _tjPlaneSizeYUVPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int)
        >
      >('tjPlaneSizeYUV');
  late final _tjPlaneSizeYUV = _tjPlaneSizeYUVPtr
      .asFunction<int Function(int, int, int, int, int)>();

  int tjPlaneWidth(int componentID, int width, int subsamp) {
    return _tjPlaneWidth(componentID, width, subsamp);
  }

  late final _tjPlaneWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
        'tjPlaneWidth',
      );
  late final _tjPlaneWidth = _tjPlaneWidthPtr
      .asFunction<int Function(int, int, int)>();

  int tjGetErrorCode(tjhandle handle) {
    return _tjGetErrorCode(handle);
  }

  late final _tjGetErrorCodePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle)>>('tjGetErrorCode');
  late final _tjGetErrorCode = _tjGetErrorCodePtr
      .asFunction<int Function(tjhandle)>();

  ffi.Pointer<ffi.Char> tjGetErrorStr2(tjhandle handle) {
    return _tjGetErrorStr2(handle);
  }

  late final _tjGetErrorStr2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(tjhandle)>>(
        'tjGetErrorStr2',
      );
  late final _tjGetErrorStr2 = _tjGetErrorStr2Ptr
      .asFunction<ffi.Pointer<ffi.Char> Function(tjhandle)>();

  ffi.Pointer<ffi.UnsignedChar> tjLoadImage(
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Int> width,
    int align,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> pixelFormat,
    int flags,
  ) {
    return _tjLoadImage(filename, width, align, height, pixelFormat, flags);
  }

  late final _tjLoadImagePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
            ffi.Int,
          )
        >
      >('tjLoadImage');
  late final _tjLoadImage = _tjLoadImagePtr
      .asFunction<
        ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          int,
        )
      >();

  int tjSaveImage(
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.UnsignedChar> buffer,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjSaveImage(
      filename,
      buffer,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjSaveImagePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('tjSaveImage');
  late final _tjSaveImage = _tjSaveImagePtr
      .asFunction<
        int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          int,
        )
      >();
}

/// Initialization options
enum TJINIT {
  /// Initialize the TurboJPEG instance for compression.
  TJINIT_COMPRESS(0),

  /// Initialize the TurboJPEG instance for decompression.
  TJINIT_DECOMPRESS(1),

  /// Initialize the TurboJPEG instance for lossless transformation (both
  /// compression and decompression.)
  TJINIT_TRANSFORM(2);

  final int value;
  const TJINIT(this.value);

  static TJINIT fromValue(int value) => switch (value) {
    0 => TJINIT_COMPRESS,
    1 => TJINIT_DECOMPRESS,
    2 => TJINIT_TRANSFORM,
    _ => throw ArgumentError('Unknown value for TJINIT: $value'),
  };
}

/// Chrominance subsampling options
///
/// When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK
/// to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of
/// the Cb and Cr (chrominance) components can be discarded or averaged together
/// to produce a smaller image with little perceptible loss of image quality.
/// (The human eye is more sensitive to small changes in brightness than to
/// small changes in color.)  This is called "chrominance subsampling".
enum TJSAMP {
  /// 4:4:4 chrominance subsampling (no chrominance subsampling)
  ///
  /// The JPEG or YUV image will contain one chrominance component for every
  /// pixel in the source image.
  TJSAMP_444(0),

  /// 4:2:2 chrominance subsampling
  ///
  /// The JPEG or YUV image will contain one chrominance component for every 2x1
  /// block of pixels in the source image.
  TJSAMP_422(1),

  /// 4:2:0 chrominance subsampling
  ///
  /// The JPEG or YUV image will contain one chrominance component for every 2x2
  /// block of pixels in the source image.
  TJSAMP_420(2),

  /// Grayscale
  ///
  /// The JPEG or YUV image will contain no chrominance components.
  TJSAMP_GRAY(3),

  /// 4:4:0 chrominance subsampling
  ///
  /// The JPEG or YUV image will contain one chrominance component for every 1x2
  /// block of pixels in the source image.
  ///
  /// @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo.
  TJSAMP_440(4),

  /// 4:1:1 chrominance subsampling
  ///
  /// The JPEG or YUV image will contain one chrominance component for every 4x1
  /// block of pixels in the source image.  All else being equal, a JPEG image
  /// with 4:1:1 subsampling is almost exactly the same size as a JPEG image
  /// with 4:2:0 subsampling, and in the aggregate, both subsampling methods
  /// produce approximately the same perceptual quality.  However, 4:1:1 is
  /// better able to reproduce sharp horizontal features.
  ///
  /// @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo.
  TJSAMP_411(5),

  /// 4:4:1 chrominance subsampling
  ///
  /// The JPEG or YUV image will contain one chrominance component for every 1x4
  /// block of pixels in the source image.  All else being equal, a JPEG image
  /// with 4:4:1 subsampling is almost exactly the same size as a JPEG image
  /// with 4:2:0 subsampling, and in the aggregate, both subsampling methods
  /// produce approximately the same perceptual quality.  However, 4:4:1 is
  /// better able to reproduce sharp vertical features.
  ///
  /// @note 4:4:1 subsampling is not fully accelerated in libjpeg-turbo.
  TJSAMP_441(6),

  /// Unknown subsampling
  ///
  /// The JPEG image uses an unusual type of chrominance subsampling.  Such
  /// images can be decompressed into packed-pixel images, but they cannot be
  /// - decompressed into planar YUV images,
  /// - losslessly transformed if #TJXOPT_CROP is specified and #TJXOPT_GRAY is
  /// not specified, or
  /// - partially decompressed using a cropping region.
  TJSAMP_UNKNOWN(-1);

  final int value;
  const TJSAMP(this.value);

  static TJSAMP fromValue(int value) => switch (value) {
    0 => TJSAMP_444,
    1 => TJSAMP_422,
    2 => TJSAMP_420,
    3 => TJSAMP_GRAY,
    4 => TJSAMP_440,
    5 => TJSAMP_411,
    6 => TJSAMP_441,
    -1 => TJSAMP_UNKNOWN,
    _ => throw ArgumentError('Unknown value for TJSAMP: $value'),
  };
}

/// Pixel formats
enum TJPF {
  /// RGB pixel format
  ///
  /// The red, green, and blue components in the image are stored in 3-sample
  /// pixels in the order R, G, B from lowest to highest memory address within
  /// each pixel.
  TJPF_RGB(0),

  /// BGR pixel format
  ///
  /// The red, green, and blue components in the image are stored in 3-sample
  /// pixels in the order B, G, R from lowest to highest memory address within
  /// each pixel.
  TJPF_BGR(1),

  /// RGBX pixel format
  ///
  /// The red, green, and blue components in the image are stored in 4-sample
  /// pixels in the order R, G, B from lowest to highest memory address within
  /// each pixel.  The X component is ignored when compressing/encoding and
  /// undefined when decompressing/decoding.
  TJPF_RGBX(2),

  /// BGRX pixel format
  ///
  /// The red, green, and blue components in the image are stored in 4-sample
  /// pixels in the order B, G, R from lowest to highest memory address within
  /// each pixel.  The X component is ignored when compressing/encoding and
  /// undefined when decompressing/decoding.
  TJPF_BGRX(3),

  /// XBGR pixel format
  ///
  /// The red, green, and blue components in the image are stored in 4-sample
  /// pixels in the order R, G, B from highest to lowest memory address within
  /// each pixel.  The X component is ignored when compressing/encoding and
  /// undefined when decompressing/decoding.
  TJPF_XBGR(4),

  /// XRGB pixel format
  ///
  /// The red, green, and blue components in the image are stored in 4-sample
  /// pixels in the order B, G, R from highest to lowest memory address within
  /// each pixel.  The X component is ignored when compressing/encoding and
  /// undefined when decompressing/decoding.
  TJPF_XRGB(5),

  /// Grayscale pixel format
  ///
  /// Each 1-sample pixel represents a luminance (brightness) level from 0 to
  /// the maximum sample value (which is, for instance, 255 for 8-bit samples or
  /// 4095 for 12-bit samples or 65535 for 16-bit samples.)
  TJPF_GRAY(6),

  /// RGBA pixel format
  ///
  /// This is the same as @ref TJPF_RGBX, except that when
  /// decompressing/decoding, the X component is guaranteed to be equal to the
  /// maximum sample value, which can be interpreted as an opaque alpha channel.
  TJPF_RGBA(7),

  /// BGRA pixel format
  ///
  /// This is the same as @ref TJPF_BGRX, except that when
  /// decompressing/decoding, the X component is guaranteed to be equal to the
  /// maximum sample value, which can be interpreted as an opaque alpha channel.
  TJPF_BGRA(8),

  /// ABGR pixel format
  ///
  /// This is the same as @ref TJPF_XBGR, except that when
  /// decompressing/decoding, the X component is guaranteed to be equal to the
  /// maximum sample value, which can be interpreted as an opaque alpha channel.
  TJPF_ABGR(9),

  /// ARGB pixel format
  ///
  /// This is the same as @ref TJPF_XRGB, except that when
  /// decompressing/decoding, the X component is guaranteed to be equal to the
  /// maximum sample value, which can be interpreted as an opaque alpha channel.
  TJPF_ARGB(10),

  /// CMYK pixel format
  ///
  /// Unlike RGB, which is an additive color model used primarily for display,
  /// CMYK (Cyan/Magenta/Yellow/Key) is a subtractive color model used primarily
  /// for printing.  In the CMYK color model, the value of each color component
  /// typically corresponds to an amount of cyan, magenta, yellow, or black ink
  /// that is applied to a white background.  In order to convert between CMYK
  /// and RGB, it is necessary to use a color management system (CMS.)  A CMS
  /// will attempt to map colors within the printer's gamut to perceptually
  /// similar colors in the display's gamut and vice versa, but the mapping is
  /// typically not 1:1 or reversible, nor can it be defined with a simple
  /// formula.  Thus, such a conversion is out of scope for a codec library.
  /// However, the TurboJPEG API allows for compressing packed-pixel CMYK images
  /// into YCCK JPEG images (see #TJCS_YCCK) and decompressing YCCK JPEG images
  /// into packed-pixel CMYK images.
  TJPF_CMYK(11),

  /// Unknown pixel format
  ///
  /// Currently this is only used by #tj3LoadImage8(), #tj3LoadImage12(), and
  /// #tj3LoadImage16().
  TJPF_UNKNOWN(-1);

  final int value;
  const TJPF(this.value);

  static TJPF fromValue(int value) => switch (value) {
    0 => TJPF_RGB,
    1 => TJPF_BGR,
    2 => TJPF_RGBX,
    3 => TJPF_BGRX,
    4 => TJPF_XBGR,
    5 => TJPF_XRGB,
    6 => TJPF_GRAY,
    7 => TJPF_RGBA,
    8 => TJPF_BGRA,
    9 => TJPF_ABGR,
    10 => TJPF_ARGB,
    11 => TJPF_CMYK,
    -1 => TJPF_UNKNOWN,
    _ => throw ArgumentError('Unknown value for TJPF: $value'),
  };
}

/// JPEG colorspaces
enum TJCS {
  /// RGB colorspace
  ///
  /// When generating the JPEG image, the R, G, and B components in the source
  /// image are reordered into image planes, but no colorspace conversion or
  /// subsampling is performed.  RGB JPEG images can be generated from and
  /// decompressed to packed-pixel images with any of the extended RGB or
  /// grayscale pixel formats, but they cannot be generated from or
  /// decompressed to planar YUV images.
  TJCS_RGB(0),

  /// YCbCr colorspace
  ///
  /// YCbCr is not an absolute colorspace but rather a mathematical
  /// transformation of RGB designed solely for storage and transmission.  YCbCr
  /// images must be converted to RGB before they can be displayed.  In the
  /// YCbCr colorspace, the Y (luminance) component represents the black & white
  /// portion of the original image, and the Cb and Cr (chrominance) components
  /// represent the color portion of the original image.  Historically, the
  /// analog equivalent of this transformation allowed the same signal to be
  /// displayed to both black & white and color televisions, but JPEG images use
  /// YCbCr primarily because it allows the color data to be optionally
  /// subsampled in order to reduce network and disk usage.  YCbCr is the most
  /// common JPEG colorspace, and YCbCr JPEG images can be generated from and
  /// decompressed to packed-pixel images with any of the extended RGB or
  /// grayscale pixel formats.  YCbCr JPEG images can also be generated from
  /// and decompressed to planar YUV images.
  TJCS_YCbCr(1),

  /// Grayscale colorspace
  ///
  /// The JPEG image retains only the luminance data (Y component), and any
  /// color data from the source image is discarded.  Grayscale JPEG images can
  /// be generated from and decompressed to packed-pixel images with any of the
  /// extended RGB or grayscale pixel formats, or they can be generated from
  /// and decompressed to planar YUV images.
  TJCS_GRAY(2),

  /// CMYK colorspace
  ///
  /// When generating the JPEG image, the C, M, Y, and K components in the
  /// source image are reordered into image planes, but no colorspace conversion
  /// or subsampling is performed.  CMYK JPEG images can only be generated from
  /// and decompressed to packed-pixel images with the CMYK pixel format.
  TJCS_CMYK(3),

  /// YCCK colorspace
  ///
  /// YCCK (AKA "YCbCrK") is not an absolute colorspace but rather a
  /// mathematical transformation of CMYK designed solely for storage and
  /// transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be
  /// reversibly transformed into YCCK, and as with YCbCr, the chrominance
  /// components in the YCCK pixels can be subsampled without incurring major
  /// perceptual loss.  YCCK JPEG images can only be generated from and
  /// decompressed to packed-pixel images with the CMYK pixel format.
  TJCS_YCCK(4);

  final int value;
  const TJCS(this.value);

  static TJCS fromValue(int value) => switch (value) {
    0 => TJCS_RGB,
    1 => TJCS_YCbCr,
    2 => TJCS_GRAY,
    3 => TJCS_CMYK,
    4 => TJCS_YCCK,
    _ => throw ArgumentError('Unknown value for TJCS: $value'),
  };
}

/// Parameters
enum TJPARAM {
  /// Error handling behavior
  ///
  /// **Value**
  /// - `0` *[default]* Allow the current compression/decompression/transform
  /// operation to complete unless a fatal error is encountered.
  /// - `1` Immediately discontinue the current
  /// compression/decompression/transform operation if a warning (non-fatal
  /// error) occurs.
  TJPARAM_STOPONWARNING(0),

  /// Row order in packed-pixel source/destination images
  ///
  /// **Value**
  /// - `0` *[default]* top-down (X11) order
  /// - `1` bottom-up (Windows, OpenGL) order
  TJPARAM_BOTTOMUP(1),

  /// JPEG destination buffer (re)allocation [compression, lossless
  /// transformation]
  ///
  /// **Value**
  /// - `0` *[default]* Attempt to allocate or reallocate the JPEG destination
  /// buffer as needed.
  /// - `1` Generate an error if the JPEG destination buffer is invalid or too
  /// small.
  TJPARAM_NOREALLOC(2),

  /// Perceptual quality of lossy JPEG images [compression only]
  ///
  /// **Value**
  /// - `1`-`100` (`1` = worst quality but best compression, `100` = best
  /// quality but worst compression) *[no default; must be explicitly
  /// specified]*
  TJPARAM_QUALITY(3),

  /// Chrominance subsampling level
  ///
  /// The JPEG or YUV image uses (decompression, decoding) or will use (lossy
  /// compression, encoding) the specified level of chrominance subsampling.
  ///
  /// **Value**
  /// - One of the @ref TJSAMP "chrominance subsampling options" *[no default;
  /// must be explicitly specified for lossy compression, encoding, and
  /// decoding]*
  TJPARAM_SUBSAMP(4),

  /// JPEG width (in pixels) [decompression only, read-only]
  TJPARAM_JPEGWIDTH(5),

  /// JPEG height (in pixels) [decompression only, read-only]
  TJPARAM_JPEGHEIGHT(6),

  /// Data precision (bits per sample)
  ///
  /// The JPEG image uses (decompression) or will use (lossless compression) the
  /// specified number of bits per sample.  This parameter also specifies the
  /// target data precision when loading a PBMPLUS file with #tj3LoadImage8(),
  /// #tj3LoadImage12(), or #tj3LoadImage16() and the source data precision when
  /// saving a PBMPLUS file with #tj3SaveImage8(), #tj3SaveImage12(), or
  /// #tj3SaveImage16().
  ///
  /// The data precision is the number of bits in the maximum sample value,
  /// which may not be the same as the width of the data type used to store the
  /// sample.
  ///
  /// **Value**
  /// - `8` or `12` for lossy JPEG images; `2` to `16` for lossless JPEG and
  /// PBMPLUS images
  ///
  /// 12-bit JPEG data precision implies #TJPARAM_OPTIMIZE unless
  /// #TJPARAM_ARITHMETIC is set.
  TJPARAM_PRECISION(7),

  /// JPEG colorspace
  ///
  /// The JPEG image uses (decompression) or will use (lossy compression) the
  /// specified colorspace.
  ///
  /// **Value**
  /// - One of the @ref TJCS "JPEG colorspaces" *[default for lossy compression:
  /// automatically selected based on the subsampling level and pixel format]*
  TJPARAM_COLORSPACE(8),

  /// Chrominance upsampling algorithm [lossy decompression only]
  ///
  /// **Value**
  /// - `0` *[default]* Use smooth upsampling when decompressing a JPEG image
  /// that was generated using chrominance subsampling.  This creates a smooth
  /// transition between neighboring chrominance components in order to reduce
  /// upsampling artifacts in the decompressed image.
  /// - `1` Use the fastest chrominance upsampling algorithm available, which
  /// may combine upsampling with color conversion.
  TJPARAM_FASTUPSAMPLE(9),

  /// DCT/IDCT algorithm [lossy compression and decompression]
  ///
  /// **Value**
  /// - `0` *[default]* Use the most accurate DCT/IDCT algorithm available.
  /// - `1` Use the fastest DCT/IDCT algorithm available.
  ///
  /// This parameter is provided mainly for backward compatibility with libjpeg,
  /// which historically implemented several different DCT/IDCT algorithms
  /// because of performance limitations with 1990s CPUs.  In the libjpeg-turbo
  /// implementation of the TurboJPEG API:
  /// - The "fast" and "accurate" DCT/IDCT algorithms perform similarly on
  /// modern x86/x86-64 CPUs that support AVX2 instructions.
  /// - The "fast" algorithm is generally only about 5-15% faster than the
  /// "accurate" algorithm on other types of CPUs.
  /// - The difference in accuracy between the "fast" and "accurate" algorithms
  /// is the most pronounced at JPEG quality levels above 90 and tends to be
  /// more pronounced with decompression than with compression.
  /// - For JPEG quality levels above 97, the "fast" algorithm degrades and is
  /// not fully accelerated, so it is slower than the "accurate" algorithm.
  TJPARAM_FASTDCT(10),

  /// Huffman table optimization [lossy compression, lossless transformation]
  ///
  /// **Value**
  /// - `0` *[default]* The JPEG image will use the default Huffman tables.
  /// - `1` Optimal Huffman tables will be computed for the JPEG image.  For
  /// lossless transformation, this can also be specified using
  /// #TJXOPT_OPTIMIZE.
  ///
  /// Huffman table optimization improves compression slightly (generally 5% or
  /// less), but it reduces compression performance considerably.
  TJPARAM_OPTIMIZE(11),

  /// Progressive JPEG
  ///
  /// In a progressive JPEG image, the DCT coefficients are split across
  /// multiple "scans" of increasing quality.  Thus, a low-quality scan
  /// containing the lowest-frequency DCT coefficients can be transmitted first
  /// and refined with subsequent higher-quality scans containing
  /// higher-frequency DCT coefficients.  When using Huffman entropy coding, the
  /// progressive JPEG format also provides an "end-of-bands (EOB) run" feature
  /// that allows large groups of zeroes, potentially spanning multiple MCUs,
  /// to be represented using only a few bytes.
  ///
  /// **Value**
  /// - `0` *[default for compression, lossless transformation]* The lossy JPEG
  /// image is (decompression) or will be (compression, lossless transformation)
  /// single-scan.
  /// - `1` The lossy JPEG image is (decompression) or will be (compression,
  /// lossless transformation) progressive.  For lossless transformation, this
  /// can also be specified using #TJXOPT_PROGRESSIVE.
  ///
  /// Progressive JPEG images generally have better compression ratios than
  /// single-scan JPEG images (much better if the image has large areas of solid
  /// color), but progressive JPEG compression and decompression is considerably
  /// slower than single-scan JPEG compression and decompression.  Can be
  /// combined with #TJPARAM_ARITHMETIC.  Implies #TJPARAM_OPTIMIZE unless
  /// #TJPARAM_ARITHMETIC is also set.
  TJPARAM_PROGRESSIVE(12),

  /// Progressive JPEG scan limit for lossy JPEG images [decompression, lossless
  /// transformation]
  ///
  /// Setting this parameter causes the decompression and transform functions to
  /// return an error if the number of scans in a progressive JPEG image exceeds
  /// the specified limit.  The primary purpose of this is to allow
  /// security-critical applications to guard against an exploit of the
  /// progressive JPEG format described in
  /// <a href="https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf" target="_blank">this report</a>.
  ///
  /// **Value**
  /// - maximum number of progressive JPEG scans that the decompression and
  /// transform functions will process *[default: `0` (no limit)]*
  ///
  /// @see #TJPARAM_PROGRESSIVE
  TJPARAM_SCANLIMIT(13),

  /// Arithmetic entropy coding
  ///
  /// **Value**
  /// - `0` *[default for compression, lossless transformation]* The lossy JPEG
  /// image uses (decompression) or will use (compression, lossless
  /// transformation) Huffman entropy coding.
  /// - `1` The lossy JPEG image uses (decompression) or will use (compression,
  /// lossless transformation) arithmetic entropy coding.  For lossless
  /// transformation, this can also be specified using #TJXOPT_ARITHMETIC.
  ///
  /// Arithmetic entropy coding generally improves compression relative to
  /// Huffman entropy coding, but it reduces compression and decompression
  /// performance considerably.  Can be combined with #TJPARAM_PROGRESSIVE.
  TJPARAM_ARITHMETIC(14),

  /// Lossless JPEG
  ///
  /// **Value**
  /// - `0` *[default for compression]* The JPEG image is (decompression) or
  /// will be (compression) lossy/DCT-based.
  /// - `1` The JPEG image is (decompression) or will be (compression)
  /// lossless/predictive.
  ///
  /// In most cases, lossless JPEG compression and decompression is considerably
  /// slower than lossy JPEG compression and decompression, and lossless JPEG
  /// images are much larger than lossy JPEG images.  Thus, lossless JPEG images
  /// are typically used only for applications that require mathematically
  /// lossless compression.  Also note that the following features are not
  /// available with lossless JPEG images:
  /// - Colorspace conversion (lossless JPEG images always use #TJCS_RGB,
  /// #TJCS_GRAY, or #TJCS_CMYK, depending on the pixel format of the source
  /// image)
  /// - Chrominance subsampling (lossless JPEG images always use #TJSAMP_444)
  /// - JPEG quality selection
  /// - DCT/IDCT algorithm selection
  /// - Progressive JPEG
  /// - Arithmetic entropy coding
  /// - Compression from/decompression to planar YUV images (this parameter is
  /// ignored by #tj3CompressFromYUV8() and #tj3CompressFromYUVPlanes8())
  /// - Decompression scaling
  /// - Lossless transformation
  ///
  /// @see #TJPARAM_LOSSLESSPSV, #TJPARAM_LOSSLESSPT
  TJPARAM_LOSSLESS(15),

  /// Lossless JPEG predictor selection value (PSV)
  ///
  /// **Value**
  /// - `1`-`7` *[default for compression: `1`]*
  ///
  /// Lossless JPEG compression shares no algorithms with lossy JPEG
  /// compression.  Instead, it uses differential pulse-code modulation (DPCM),
  /// an algorithm whereby each sample is encoded as the difference between the
  /// sample's value and a "predictor", which is based on the values of
  /// neighboring samples.  If Ra is the sample immediately to the left of the
  /// current sample, Rb is the sample immediately above the current sample, and
  /// Rc is the sample diagonally to the left and above the current sample, then
  /// the relationship between the predictor selection value and the predictor
  /// is as follows:
  ///
  /// PSV | Predictor
  /// ----|----------
  /// 1   | Ra
  /// 2   | Rb
  /// 3   | Rc
  /// 4   | Ra + Rb  Rc
  /// 5   | Ra + (Rb  Rc) / 2
  /// 6   | Rb + (Ra  Rc) / 2
  /// 7   | (Ra + Rb) / 2
  ///
  /// Predictors 1-3 are 1-dimensional predictors, whereas Predictors 4-7 are
  /// 2-dimensional predictors.  The best predictor for a particular image
  /// depends on the image.
  ///
  /// @see #TJPARAM_LOSSLESS
  TJPARAM_LOSSLESSPSV(16),

  /// Lossless JPEG point transform (Pt)
  ///
  /// **Value**
  /// - `0` through ***precision*** *- 1*, where ***precision*** is the JPEG
  /// data precision in bits *[default for compression: `0`]*
  ///
  /// A point transform value of `0` is necessary in order to generate a fully
  /// lossless JPEG image.  (A non-zero point transform value right-shifts the
  /// input samples by the specified number of bits, which is effectively a form
  /// of lossy color quantization.)
  ///
  /// @see #TJPARAM_LOSSLESS, #TJPARAM_PRECISION
  TJPARAM_LOSSLESSPT(17),

  /// JPEG restart marker interval in MCUs [lossy compression,
  /// lossless transformation]
  ///
  /// The nature of entropy coding is such that a corrupt JPEG image cannot
  /// be decompressed beyond the point of corruption unless it contains restart
  /// markers.  A restart marker stops and restarts the entropy coding algorithm
  /// so that, if a JPEG image is corrupted, decompression can resume at the
  /// next marker.  Thus, adding more restart markers improves the fault
  /// tolerance of the JPEG image, but adding too many restart markers can
  /// adversely affect the compression ratio and performance.
  ///
  /// In typical JPEG images, an MCU (Minimum Coded Unit) is the minimum set of
  /// interleaved "data units" (8x8 DCT blocks if the image is lossy or samples
  /// if the image is lossless) necessary to represent at least one data unit
  /// per component.  (For example, an MCU in an interleaved lossy JPEG image
  /// that uses 4:2:2 subsampling consists of two luminance blocks followed by
  /// one block for each chrominance component.)  In single-component or
  /// non-interleaved JPEG images, an MCU is the same as a data unit.
  ///
  /// **Value**
  /// - the number of MCUs between each restart marker *[default: `0` (no
  /// restart markers)]*
  ///
  /// Setting this parameter to a non-zero value sets #TJPARAM_RESTARTROWS to 0.
  TJPARAM_RESTARTBLOCKS(18),

  /// JPEG restart marker interval in MCU rows [compression,
  /// lossless transformation]
  ///
  /// See #TJPARAM_RESTARTBLOCKS for a description of restart markers and MCUs.
  /// An MCU row is a row of MCUs spanning the entire width of the image.
  ///
  /// **Value**
  /// - the number of MCU rows between each restart marker *[default: `0` (no
  /// restart markers)]*
  ///
  /// Setting this parameter to a non-zero value sets #TJPARAM_RESTARTBLOCKS to
  /// 0.
  TJPARAM_RESTARTROWS(19),

  /// JPEG horizontal pixel density
  ///
  /// **Value**
  /// - The JPEG image has (decompression) or will have (compression) the
  /// specified horizontal pixel density *[default for compression: `1`]*.
  ///
  /// This value is stored in or read from the JPEG header.  It does not affect
  /// the contents of the JPEG image.  Note that this parameter is set by
  /// #tj3LoadImage8() when loading a Windows BMP file that contains pixel
  /// density information, and the value of this parameter is stored to a
  /// Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS
  /// is `2`.
  ///
  /// This parameter has no effect unless the JPEG colorspace (see
  /// #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY.
  ///
  /// @see TJPARAM_DENSITYUNITS
  TJPARAM_XDENSITY(20),

  /// JPEG vertical pixel density
  ///
  /// **Value**
  /// - The JPEG image has (decompression) or will have (compression) the
  /// specified vertical pixel density *[default for compression: `1`]*.
  ///
  /// This value is stored in or read from the JPEG header.  It does not affect
  /// the contents of the JPEG image.  Note that this parameter is set by
  /// #tj3LoadImage8() when loading a Windows BMP file that contains pixel
  /// density information, and the value of this parameter is stored to a
  /// Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS
  /// is `2`.
  ///
  /// This parameter has no effect unless the JPEG colorspace (see
  /// #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY.
  ///
  /// @see TJPARAM_DENSITYUNITS
  TJPARAM_YDENSITY(21),

  /// JPEG pixel density units
  ///
  /// **Value**
  /// - `0` *[default for compression]* The pixel density of the JPEG image is
  /// expressed (decompression) or will be expressed (compression) in unknown
  /// units.
  /// - `1` The pixel density of the JPEG image is expressed (decompression) or
  /// will be expressed (compression) in units of pixels/inch.
  /// - `2` The pixel density of the JPEG image is expressed (decompression) or
  /// will be expressed (compression) in units of pixels/cm.
  ///
  /// This value is stored in or read from the JPEG header.  It does not affect
  /// the contents of the JPEG image.  Note that this parameter is set by
  /// #tj3LoadImage8() when loading a Windows BMP file that contains pixel
  /// density information, and the value of this parameter is stored to a
  /// Windows BMP file by #tj3SaveImage8() if the value is `2`.
  ///
  /// This parameter has no effect unless the JPEG colorspace (see
  /// #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY.
  ///
  /// @see TJPARAM_XDENSITY, TJPARAM_YDENSITY
  TJPARAM_DENSITYUNITS(22),

  /// Memory limit for intermediate buffers
  ///
  /// **Value**
  /// - the maximum amount of memory (in megabytes) that will be allocated for
  /// intermediate buffers, which are used with progressive JPEG compression and
  /// decompression, Huffman table optimization, lossless JPEG compression, and
  /// lossless transformation *[default: `0` (no limit)]*
  TJPARAM_MAXMEMORY(23),

  /// Image size limit [decompression, lossless transformation, packed-pixel
  /// image loading]
  ///
  /// Setting this parameter causes the decompression, transform, and image
  /// loading functions to return an error if the number of pixels in the source
  /// image exceeds the specified limit.  This allows security-critical
  /// applications to guard against excessive memory consumption.
  ///
  /// **Value**
  /// - maximum number of pixels that the decompression, transform, and image
  /// loading functions will process *[default: `0` (no limit)]*
  TJPARAM_MAXPIXELS(24),

  /// Marker copying behavior [decompression, lossless transformation]
  ///
  /// **Value [lossless transformation]**
  /// - `0` Do not copy any extra markers (including comments, JFIF thumbnails,
  /// Exif data, and ICC profile data) from the source image to the destination
  /// image.
  /// - `1` Do not copy any extra markers, except comment (COM) markers, from
  /// the source image to the destination image.
  /// - `2` *[default]* Copy all extra markers from the source image to the
  /// destination image.
  /// - `3` Copy all extra markers, except ICC profile data (APP2 markers), from
  /// the source image to the destination image.
  /// - `4` Do not copy any extra markers, except ICC profile data (APP2
  /// markers), from the source image to the destination image.
  ///
  /// #TJXOPT_COPYNONE overrides this parameter for a particular transform.
  /// This parameter overrides any ICC profile that was previously associated
  /// with the TurboJPEG instance using #tj3SetICCProfile().
  ///
  /// When decompressing, #tj3DecompressHeader() extracts the ICC profile from a
  /// JPEG image if this parameter is set to `2` or `4`.  #tj3GetICCProfile()
  /// can then be used to retrieve the profile.
  TJPARAM_SAVEMARKERS(25);

  final int value;
  const TJPARAM(this.value);

  static TJPARAM fromValue(int value) => switch (value) {
    0 => TJPARAM_STOPONWARNING,
    1 => TJPARAM_BOTTOMUP,
    2 => TJPARAM_NOREALLOC,
    3 => TJPARAM_QUALITY,
    4 => TJPARAM_SUBSAMP,
    5 => TJPARAM_JPEGWIDTH,
    6 => TJPARAM_JPEGHEIGHT,
    7 => TJPARAM_PRECISION,
    8 => TJPARAM_COLORSPACE,
    9 => TJPARAM_FASTUPSAMPLE,
    10 => TJPARAM_FASTDCT,
    11 => TJPARAM_OPTIMIZE,
    12 => TJPARAM_PROGRESSIVE,
    13 => TJPARAM_SCANLIMIT,
    14 => TJPARAM_ARITHMETIC,
    15 => TJPARAM_LOSSLESS,
    16 => TJPARAM_LOSSLESSPSV,
    17 => TJPARAM_LOSSLESSPT,
    18 => TJPARAM_RESTARTBLOCKS,
    19 => TJPARAM_RESTARTROWS,
    20 => TJPARAM_XDENSITY,
    21 => TJPARAM_YDENSITY,
    22 => TJPARAM_DENSITYUNITS,
    23 => TJPARAM_MAXMEMORY,
    24 => TJPARAM_MAXPIXELS,
    25 => TJPARAM_SAVEMARKERS,
    _ => throw ArgumentError('Unknown value for TJPARAM: $value'),
  };
}

/// Error codes
enum TJERR {
  /// The error was non-fatal and recoverable, but the destination image may
  /// still be corrupt.
  TJERR_WARNING(0),

  /// The error was fatal and non-recoverable.
  TJERR_FATAL(1);

  final int value;
  const TJERR(this.value);

  static TJERR fromValue(int value) => switch (value) {
    0 => TJERR_WARNING,
    1 => TJERR_FATAL,
    _ => throw ArgumentError('Unknown value for TJERR: $value'),
  };
}

/// Transform operations for #tj3Transform()
enum TJXOP {
  /// Do not transform the position of the image pixels.
  TJXOP_NONE(0),

  /// Flip (mirror) image horizontally.  This transform is imperfect if there
  /// are any partial iMCUs on the right edge (see #TJXOPT_PERFECT.)
  TJXOP_HFLIP(1),

  /// Flip (mirror) image vertically.  This transform is imperfect if there are
  /// any partial iMCUs on the bottom edge (see #TJXOPT_PERFECT.)
  TJXOP_VFLIP(2),

  /// Transpose image (flip/mirror along upper left to lower right axis.)  This
  /// transform is always perfect.
  TJXOP_TRANSPOSE(3),

  /// Transverse transpose image (flip/mirror along upper right to lower left
  /// axis.)  This transform is imperfect if there are any partial iMCUs in the
  /// image (see #TJXOPT_PERFECT.)
  TJXOP_TRANSVERSE(4),

  /// Rotate image clockwise by 90 degrees.  This transform is imperfect if
  /// there are any partial iMCUs on the bottom edge (see #TJXOPT_PERFECT.)
  TJXOP_ROT90(5),

  /// Rotate image 180 degrees.  This transform is imperfect if there are any
  /// partial iMCUs in the image (see #TJXOPT_PERFECT.)
  TJXOP_ROT180(6),

  /// Rotate image counter-clockwise by 90 degrees.  This transform is imperfect
  /// if there are any partial iMCUs on the right edge (see #TJXOPT_PERFECT.)
  TJXOP_ROT270(7);

  final int value;
  const TJXOP(this.value);

  static TJXOP fromValue(int value) => switch (value) {
    0 => TJXOP_NONE,
    1 => TJXOP_HFLIP,
    2 => TJXOP_VFLIP,
    3 => TJXOP_TRANSPOSE,
    4 => TJXOP_TRANSVERSE,
    5 => TJXOP_ROT90,
    6 => TJXOP_ROT180,
    7 => TJXOP_ROT270,
    _ => throw ArgumentError('Unknown value for TJXOP: $value'),
  };
}

/// Scaling factor
final class tjscalingfactor extends ffi.Struct {
  /// Numerator
  @ffi.Int()
  external int num;

  /// Denominator
  @ffi.Int()
  external int denom;
}

/// Cropping region
final class tjregion extends ffi.Struct {
  /// The left boundary of the cropping region.  For lossless transformation,
  /// this must be evenly divisible by the iMCU width (see #tjMCUWidth) of the
  /// destination image.  For decompression, this must be evenly divisible by
  /// the scaled iMCU width of the source image.
  @ffi.Int()
  external int x;

  /// The upper boundary of the cropping region.  For lossless transformation,
  /// this must be evenly divisible by the iMCU height (see #tjMCUHeight) of the
  /// destination image.
  @ffi.Int()
  external int y;

  /// The width of the cropping region.  Setting this to 0 is the equivalent of
  /// setting it to the width of the source JPEG image - x.
  @ffi.Int()
  external int w;

  /// The height of the cropping region.  Setting this to 0 is the equivalent of
  /// setting it to the height of the source JPEG image - y.
  @ffi.Int()
  external int h;
}

/// Lossless transform
final class tjtransform extends ffi.Struct {
  /// Cropping region
  external tjregion r;

  /// One of the @ref TJXOP "transform operations"
  @ffi.Int()
  external int op;

  /// The bitwise OR of one of more of the @ref TJXOPT_ARITHMETIC
  /// "transform options"
  @ffi.Int()
  external int options;

  /// Arbitrary data that can be accessed within the body of the callback
  /// function
  external ffi.Pointer<ffi.Void> data;

  /// A callback function that can be used to modify the DCT coefficients after
  /// they are losslessly transformed but before they are transcoded to a new
  /// JPEG image.  This allows for custom filters or other transformations to be
  /// applied in the frequency domain.
  ///
  /// @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:
  /// This pointer is not guaranteed to be valid once the callback returns, so
  /// applications wishing to hand off the DCT coefficients to another function
  /// or library should make a copy of them within the body of the callback.)
  ///
  /// @param arrayRegion #tjregion structure containing the width and height of
  /// the array pointed to by `coeffs` as well as its offset relative to the
  /// component plane.  TurboJPEG implementations may choose to split each
  /// component plane into multiple DCT coefficient arrays and call the callback
  /// function once for each array.
  ///
  /// @param planeRegion #tjregion structure containing the width and height of
  /// the component plane to which `coeffs` belongs
  ///
  /// @param componentID ID number of the component plane to which `coeffs`
  /// belongs.  (Y, Cb, and Cr have, respectively, ID's of 0, 1, and 2 in
  /// typical JPEG images.)
  ///
  /// @param transformID ID number of the transformed image to which `coeffs`
  /// belongs.  This is the same as the index of the transform in the
  /// `transforms` array that was passed to #tj3Transform().
  ///
  /// @param transform a pointer to a #tjtransform structure that specifies the
  /// parameters and/or cropping region for this transform
  ///
  /// @return 0 if the callback was successful, or -1 if an error occurred.
  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Short> coeffs,
        tjregion arrayRegion,
        tjregion planeRegion,
        ffi.Int componentID,
        ffi.Int transformID,
        ffi.Pointer<tjtransform> transform,
      )
    >
  >
  customFilter;
}

/// TurboJPEG instance handle
typedef tjhandle = ffi.Pointer<ffi.Void>;

const int TJ_NUMINIT = 3;

const int TJ_NUMSAMP = 7;

const int TJ_NUMPF = 12;

const int TJ_NUMCS = 5;

const int TJ_NUMERR = 2;

const int TJ_NUMXOP = 8;

const int TJXOPT_PERFECT = 1;

const int TJXOPT_TRIM = 2;

const int TJXOPT_CROP = 4;

const int TJXOPT_GRAY = 8;

const int TJXOPT_NOOUTPUT = 16;

const int TJXOPT_PROGRESSIVE = 32;

const int TJXOPT_COPYNONE = 64;

const int TJXOPT_ARITHMETIC = 128;

const int TJXOPT_OPTIMIZE = 256;

const int NUMSUBOPT = 7;

const int TJ_444 = 0;

const int TJ_422 = 1;

const int TJ_420 = 2;

const int TJ_411 = 2;

const int TJ_GRAYSCALE = 3;

const int TJ_BGR = 1;

const int TJ_BOTTOMUP = 2;

const int TJ_FORCEMMX = 8;

const int TJ_FORCESSE = 16;

const int TJ_FORCESSE2 = 32;

const int TJ_ALPHAFIRST = 64;

const int TJ_FORCESSE3 = 128;

const int TJ_FASTUPSAMPLE = 256;

const int TJ_YUV = 512;

const int TJFLAG_BOTTOMUP = 2;

const int TJFLAG_FORCEMMX = 8;

const int TJFLAG_FORCESSE = 16;

const int TJFLAG_FORCESSE2 = 32;

const int TJFLAG_FORCESSE3 = 128;

const int TJFLAG_FASTUPSAMPLE = 256;

const int TJFLAG_NOREALLOC = 1024;

const int TJFLAG_FASTDCT = 2048;

const int TJFLAG_ACCURATEDCT = 4096;

const int TJFLAG_STOPONWARNING = 8192;

const int TJFLAG_PROGRESSIVE = 16384;

const int TJFLAG_LIMITSCANS = 32768;
